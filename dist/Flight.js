// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: Flight.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";
export const protobufPackage = "arrow.flight.protocol";
/**
 * The result of a cancel operation.
 *
 * This is used by CancelFlightInfoResult.status.
 */
export var CancelStatus;
(function (CancelStatus) {
    /**
     * CANCEL_STATUS_UNSPECIFIED - The cancellation status is unknown. Servers should avoid using
     * this value (send a NOT_FOUND error if the requested query is
     * not known). Clients can retry the request.
     */
    CancelStatus[CancelStatus["CANCEL_STATUS_UNSPECIFIED"] = 0] = "CANCEL_STATUS_UNSPECIFIED";
    /**
     * CANCEL_STATUS_CANCELLED - The cancellation request is complete. Subsequent requests with
     * the same payload may return CANCELLED or a NOT_FOUND error.
     */
    CancelStatus[CancelStatus["CANCEL_STATUS_CANCELLED"] = 1] = "CANCEL_STATUS_CANCELLED";
    /**
     * CANCEL_STATUS_CANCELLING - The cancellation request is in progress. The client may retry
     * the cancellation request.
     */
    CancelStatus[CancelStatus["CANCEL_STATUS_CANCELLING"] = 2] = "CANCEL_STATUS_CANCELLING";
    /**
     * CANCEL_STATUS_NOT_CANCELLABLE - The query is not cancellable. The client should not retry the
     * cancellation request.
     */
    CancelStatus[CancelStatus["CANCEL_STATUS_NOT_CANCELLABLE"] = 3] = "CANCEL_STATUS_NOT_CANCELLABLE";
    CancelStatus[CancelStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CancelStatus || (CancelStatus = {}));
/** Describes what type of descriptor is defined. */
export var FlightDescriptor_DescriptorType;
(function (FlightDescriptor_DescriptorType) {
    /** UNKNOWN - Protobuf pattern, not used. */
    FlightDescriptor_DescriptorType[FlightDescriptor_DescriptorType["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * PATH - A named path that identifies a dataset. A path is composed of a string
     * or list of strings describing a particular dataset. This is conceptually
     *  similar to a path inside a filesystem.
     */
    FlightDescriptor_DescriptorType[FlightDescriptor_DescriptorType["PATH"] = 1] = "PATH";
    /** CMD - An opaque command to generate a dataset. */
    FlightDescriptor_DescriptorType[FlightDescriptor_DescriptorType["CMD"] = 2] = "CMD";
    FlightDescriptor_DescriptorType[FlightDescriptor_DescriptorType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FlightDescriptor_DescriptorType || (FlightDescriptor_DescriptorType = {}));
export var SetSessionOptionsResult_ErrorValue;
(function (SetSessionOptionsResult_ErrorValue) {
    /**
     * UNSPECIFIED - Protobuf deserialization fallback value: The status is unknown or unrecognized.
     * Servers should avoid using this value. The request may be retried by the client.
     */
    SetSessionOptionsResult_ErrorValue[SetSessionOptionsResult_ErrorValue["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /** INVALID_NAME - The given session option name is invalid. */
    SetSessionOptionsResult_ErrorValue[SetSessionOptionsResult_ErrorValue["INVALID_NAME"] = 1] = "INVALID_NAME";
    /** INVALID_VALUE - The session option value or type is invalid. */
    SetSessionOptionsResult_ErrorValue[SetSessionOptionsResult_ErrorValue["INVALID_VALUE"] = 2] = "INVALID_VALUE";
    /** ERROR - The session option cannot be set. */
    SetSessionOptionsResult_ErrorValue[SetSessionOptionsResult_ErrorValue["ERROR"] = 3] = "ERROR";
    SetSessionOptionsResult_ErrorValue[SetSessionOptionsResult_ErrorValue["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SetSessionOptionsResult_ErrorValue || (SetSessionOptionsResult_ErrorValue = {}));
export var CloseSessionResult_Status;
(function (CloseSessionResult_Status) {
    /**
     * UNSPECIFIED - Protobuf deserialization fallback value: The session close status is unknown or
     * not recognized. Servers should avoid using this value (send a NOT_FOUND error if
     * the requested session is not known or expired). Clients can retry the request.
     */
    CloseSessionResult_Status[CloseSessionResult_Status["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * CLOSED - The session close request is complete. Subsequent requests with
     * the same session produce a NOT_FOUND error.
     */
    CloseSessionResult_Status[CloseSessionResult_Status["CLOSED"] = 1] = "CLOSED";
    /**
     * CLOSING - The session close request is in progress. The client may retry
     * the close request.
     */
    CloseSessionResult_Status[CloseSessionResult_Status["CLOSING"] = 2] = "CLOSING";
    /**
     * NOT_CLOSEABLE - The session is not closeable. The client should not retry the
     * close request.
     */
    CloseSessionResult_Status[CloseSessionResult_Status["NOT_CLOSEABLE"] = 3] = "NOT_CLOSEABLE";
    CloseSessionResult_Status[CloseSessionResult_Status["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CloseSessionResult_Status || (CloseSessionResult_Status = {}));
function createBaseHandshakeRequest() {
    return { protocolVersion: 0, payload: new Uint8Array(0) };
}
export const HandshakeRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.protocolVersion !== 0) {
            writer.uint32(8).uint64(message.protocolVersion);
        }
        if (message.payload.length !== 0) {
            writer.uint32(18).bytes(message.payload);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHandshakeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.protocolVersion = longToNumber(reader.uint64());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.payload = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return HandshakeRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHandshakeRequest();
        message.protocolVersion = object.protocolVersion ?? 0;
        message.payload = object.payload ?? new Uint8Array(0);
        return message;
    },
};
function createBaseHandshakeResponse() {
    return { protocolVersion: 0, payload: new Uint8Array(0) };
}
export const HandshakeResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.protocolVersion !== 0) {
            writer.uint32(8).uint64(message.protocolVersion);
        }
        if (message.payload.length !== 0) {
            writer.uint32(18).bytes(message.payload);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHandshakeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.protocolVersion = longToNumber(reader.uint64());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.payload = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return HandshakeResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHandshakeResponse();
        message.protocolVersion = object.protocolVersion ?? 0;
        message.payload = object.payload ?? new Uint8Array(0);
        return message;
    },
};
function createBaseBasicAuth() {
    return { username: "", password: "" };
}
export const BasicAuth = {
    encode(message, writer = new BinaryWriter()) {
        if (message.username !== "") {
            writer.uint32(18).string(message.username);
        }
        if (message.password !== "") {
            writer.uint32(26).string(message.password);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBasicAuth();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.username = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.password = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return BasicAuth.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBasicAuth();
        message.username = object.username ?? "";
        message.password = object.password ?? "";
        return message;
    },
};
function createBaseEmpty() {
    return {};
}
export const Empty = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEmpty();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return Empty.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseEmpty();
        return message;
    },
};
function createBaseActionType() {
    return { type: "", description: "" };
}
export const ActionType = {
    encode(message, writer = new BinaryWriter()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionType();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionType.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActionType();
        message.type = object.type ?? "";
        message.description = object.description ?? "";
        return message;
    },
};
function createBaseCriteria() {
    return { expression: new Uint8Array(0) };
}
export const Criteria = {
    encode(message, writer = new BinaryWriter()) {
        if (message.expression.length !== 0) {
            writer.uint32(10).bytes(message.expression);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCriteria();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.expression = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return Criteria.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCriteria();
        message.expression = object.expression ?? new Uint8Array(0);
        return message;
    },
};
function createBaseAction() {
    return { type: "", body: new Uint8Array(0) };
}
export const Action = {
    encode(message, writer = new BinaryWriter()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        if (message.body.length !== 0) {
            writer.uint32(18).bytes(message.body);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.body = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return Action.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAction();
        message.type = object.type ?? "";
        message.body = object.body ?? new Uint8Array(0);
        return message;
    },
};
function createBaseResult() {
    return { body: new Uint8Array(0) };
}
export const Result = {
    encode(message, writer = new BinaryWriter()) {
        if (message.body.length !== 0) {
            writer.uint32(10).bytes(message.body);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.body = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return Result.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResult();
        message.body = object.body ?? new Uint8Array(0);
        return message;
    },
};
function createBaseSchemaResult() {
    return { schema: new Uint8Array(0) };
}
export const SchemaResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.schema.length !== 0) {
            writer.uint32(10).bytes(message.schema);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSchemaResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.schema = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return SchemaResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSchemaResult();
        message.schema = object.schema ?? new Uint8Array(0);
        return message;
    },
};
function createBaseFlightDescriptor() {
    return { type: 0, cmd: new Uint8Array(0), path: [] };
}
export const FlightDescriptor = {
    encode(message, writer = new BinaryWriter()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.cmd.length !== 0) {
            writer.uint32(18).bytes(message.cmd);
        }
        for (const v of message.path) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlightDescriptor();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.cmd = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.path.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return FlightDescriptor.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlightDescriptor();
        message.type = object.type ?? 0;
        message.cmd = object.cmd ?? new Uint8Array(0);
        message.path = object.path?.map((e) => e) || [];
        return message;
    },
};
function createBaseFlightInfo() {
    return {
        schema: new Uint8Array(0),
        flightDescriptor: undefined,
        endpoint: [],
        totalRecords: 0,
        totalBytes: 0,
        ordered: false,
        appMetadata: new Uint8Array(0),
    };
}
export const FlightInfo = {
    encode(message, writer = new BinaryWriter()) {
        if (message.schema.length !== 0) {
            writer.uint32(10).bytes(message.schema);
        }
        if (message.flightDescriptor !== undefined) {
            FlightDescriptor.encode(message.flightDescriptor, writer.uint32(18).fork()).join();
        }
        for (const v of message.endpoint) {
            FlightEndpoint.encode(v, writer.uint32(26).fork()).join();
        }
        if (message.totalRecords !== 0) {
            writer.uint32(32).int64(message.totalRecords);
        }
        if (message.totalBytes !== 0) {
            writer.uint32(40).int64(message.totalBytes);
        }
        if (message.ordered !== false) {
            writer.uint32(48).bool(message.ordered);
        }
        if (message.appMetadata.length !== 0) {
            writer.uint32(58).bytes(message.appMetadata);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlightInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.schema = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.flightDescriptor = FlightDescriptor.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.endpoint.push(FlightEndpoint.decode(reader, reader.uint32()));
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.totalRecords = longToNumber(reader.int64());
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.totalBytes = longToNumber(reader.int64());
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.ordered = reader.bool();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.appMetadata = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return FlightInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlightInfo();
        message.schema = object.schema ?? new Uint8Array(0);
        message.flightDescriptor = (object.flightDescriptor !== undefined && object.flightDescriptor !== null)
            ? FlightDescriptor.fromPartial(object.flightDescriptor)
            : undefined;
        message.endpoint = object.endpoint?.map((e) => FlightEndpoint.fromPartial(e)) || [];
        message.totalRecords = object.totalRecords ?? 0;
        message.totalBytes = object.totalBytes ?? 0;
        message.ordered = object.ordered ?? false;
        message.appMetadata = object.appMetadata ?? new Uint8Array(0);
        return message;
    },
};
function createBasePollInfo() {
    return { info: undefined, flightDescriptor: undefined, progress: undefined, expirationTime: undefined };
}
export const PollInfo = {
    encode(message, writer = new BinaryWriter()) {
        if (message.info !== undefined) {
            FlightInfo.encode(message.info, writer.uint32(10).fork()).join();
        }
        if (message.flightDescriptor !== undefined) {
            FlightDescriptor.encode(message.flightDescriptor, writer.uint32(18).fork()).join();
        }
        if (message.progress !== undefined) {
            writer.uint32(25).double(message.progress);
        }
        if (message.expirationTime !== undefined) {
            Timestamp.encode(toTimestamp(message.expirationTime), writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePollInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.info = FlightInfo.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.flightDescriptor = FlightDescriptor.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 25) {
                        break;
                    }
                    message.progress = reader.double();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.expirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return PollInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePollInfo();
        message.info = (object.info !== undefined && object.info !== null)
            ? FlightInfo.fromPartial(object.info)
            : undefined;
        message.flightDescriptor = (object.flightDescriptor !== undefined && object.flightDescriptor !== null)
            ? FlightDescriptor.fromPartial(object.flightDescriptor)
            : undefined;
        message.progress = object.progress ?? undefined;
        message.expirationTime = object.expirationTime ?? undefined;
        return message;
    },
};
function createBaseCancelFlightInfoRequest() {
    return { info: undefined };
}
export const CancelFlightInfoRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.info !== undefined) {
            FlightInfo.encode(message.info, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCancelFlightInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.info = FlightInfo.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CancelFlightInfoRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCancelFlightInfoRequest();
        message.info = (object.info !== undefined && object.info !== null)
            ? FlightInfo.fromPartial(object.info)
            : undefined;
        return message;
    },
};
function createBaseCancelFlightInfoResult() {
    return { status: 0 };
}
export const CancelFlightInfoResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.status !== 0) {
            writer.uint32(8).int32(message.status);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCancelFlightInfoResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CancelFlightInfoResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCancelFlightInfoResult();
        message.status = object.status ?? 0;
        return message;
    },
};
function createBaseTicket() {
    return { ticket: new Uint8Array(0) };
}
export const Ticket = {
    encode(message, writer = new BinaryWriter()) {
        if (message.ticket.length !== 0) {
            writer.uint32(10).bytes(message.ticket);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTicket();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ticket = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return Ticket.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTicket();
        message.ticket = object.ticket ?? new Uint8Array(0);
        return message;
    },
};
function createBaseLocation() {
    return { uri: "" };
}
export const Location = {
    encode(message, writer = new BinaryWriter()) {
        if (message.uri !== "") {
            writer.uint32(10).string(message.uri);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLocation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.uri = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return Location.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLocation();
        message.uri = object.uri ?? "";
        return message;
    },
};
function createBaseFlightEndpoint() {
    return { ticket: undefined, location: [], expirationTime: undefined, appMetadata: new Uint8Array(0) };
}
export const FlightEndpoint = {
    encode(message, writer = new BinaryWriter()) {
        if (message.ticket !== undefined) {
            Ticket.encode(message.ticket, writer.uint32(10).fork()).join();
        }
        for (const v of message.location) {
            Location.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.expirationTime !== undefined) {
            Timestamp.encode(toTimestamp(message.expirationTime), writer.uint32(26).fork()).join();
        }
        if (message.appMetadata.length !== 0) {
            writer.uint32(34).bytes(message.appMetadata);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlightEndpoint();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ticket = Ticket.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.location.push(Location.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.expirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.appMetadata = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return FlightEndpoint.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlightEndpoint();
        message.ticket = (object.ticket !== undefined && object.ticket !== null)
            ? Ticket.fromPartial(object.ticket)
            : undefined;
        message.location = object.location?.map((e) => Location.fromPartial(e)) || [];
        message.expirationTime = object.expirationTime ?? undefined;
        message.appMetadata = object.appMetadata ?? new Uint8Array(0);
        return message;
    },
};
function createBaseRenewFlightEndpointRequest() {
    return { endpoint: undefined };
}
export const RenewFlightEndpointRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.endpoint !== undefined) {
            FlightEndpoint.encode(message.endpoint, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRenewFlightEndpointRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.endpoint = FlightEndpoint.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return RenewFlightEndpointRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRenewFlightEndpointRequest();
        message.endpoint = (object.endpoint !== undefined && object.endpoint !== null)
            ? FlightEndpoint.fromPartial(object.endpoint)
            : undefined;
        return message;
    },
};
function createBaseFlightData() {
    return {
        flightDescriptor: undefined,
        dataHeader: new Uint8Array(0),
        appMetadata: new Uint8Array(0),
        dataBody: new Uint8Array(0),
    };
}
export const FlightData = {
    encode(message, writer = new BinaryWriter()) {
        if (message.flightDescriptor !== undefined) {
            FlightDescriptor.encode(message.flightDescriptor, writer.uint32(10).fork()).join();
        }
        if (message.dataHeader.length !== 0) {
            writer.uint32(18).bytes(message.dataHeader);
        }
        if (message.appMetadata.length !== 0) {
            writer.uint32(26).bytes(message.appMetadata);
        }
        if (message.dataBody.length !== 0) {
            writer.uint32(8002).bytes(message.dataBody);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlightData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.flightDescriptor = FlightDescriptor.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.dataHeader = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.appMetadata = reader.bytes();
                    continue;
                }
                case 1000: {
                    if (tag !== 8002) {
                        break;
                    }
                    message.dataBody = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return FlightData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFlightData();
        message.flightDescriptor = (object.flightDescriptor !== undefined && object.flightDescriptor !== null)
            ? FlightDescriptor.fromPartial(object.flightDescriptor)
            : undefined;
        message.dataHeader = object.dataHeader ?? new Uint8Array(0);
        message.appMetadata = object.appMetadata ?? new Uint8Array(0);
        message.dataBody = object.dataBody ?? new Uint8Array(0);
        return message;
    },
};
function createBasePutResult() {
    return { appMetadata: new Uint8Array(0) };
}
export const PutResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.appMetadata.length !== 0) {
            writer.uint32(10).bytes(message.appMetadata);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePutResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.appMetadata = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return PutResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePutResult();
        message.appMetadata = object.appMetadata ?? new Uint8Array(0);
        return message;
    },
};
function createBaseSessionOptionValue() {
    return {
        stringValue: undefined,
        boolValue: undefined,
        int64Value: undefined,
        doubleValue: undefined,
        stringListValue: undefined,
    };
}
export const SessionOptionValue = {
    encode(message, writer = new BinaryWriter()) {
        if (message.stringValue !== undefined) {
            writer.uint32(10).string(message.stringValue);
        }
        if (message.boolValue !== undefined) {
            writer.uint32(16).bool(message.boolValue);
        }
        if (message.int64Value !== undefined) {
            writer.uint32(25).sfixed64(message.int64Value);
        }
        if (message.doubleValue !== undefined) {
            writer.uint32(33).double(message.doubleValue);
        }
        if (message.stringListValue !== undefined) {
            SessionOptionValue_StringListValue.encode(message.stringListValue, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSessionOptionValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.stringValue = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.boolValue = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 25) {
                        break;
                    }
                    message.int64Value = longToNumber(reader.sfixed64());
                    continue;
                }
                case 4: {
                    if (tag !== 33) {
                        break;
                    }
                    message.doubleValue = reader.double();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.stringListValue = SessionOptionValue_StringListValue.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return SessionOptionValue.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSessionOptionValue();
        message.stringValue = object.stringValue ?? undefined;
        message.boolValue = object.boolValue ?? undefined;
        message.int64Value = object.int64Value ?? undefined;
        message.doubleValue = object.doubleValue ?? undefined;
        message.stringListValue = (object.stringListValue !== undefined && object.stringListValue !== null)
            ? SessionOptionValue_StringListValue.fromPartial(object.stringListValue)
            : undefined;
        return message;
    },
};
function createBaseSessionOptionValue_StringListValue() {
    return { values: [] };
}
export const SessionOptionValue_StringListValue = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.values) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSessionOptionValue_StringListValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.values.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return SessionOptionValue_StringListValue.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSessionOptionValue_StringListValue();
        message.values = object.values?.map((e) => e) || [];
        return message;
    },
};
function createBaseSetSessionOptionsRequest() {
    return { sessionOptions: {} };
}
export const SetSessionOptionsRequest = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.sessionOptions).forEach(([key, value]) => {
            SetSessionOptionsRequest_SessionOptionsEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetSessionOptionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = SetSessionOptionsRequest_SessionOptionsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.sessionOptions[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return SetSessionOptionsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetSessionOptionsRequest();
        message.sessionOptions = Object.entries(object.sessionOptions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = SessionOptionValue.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseSetSessionOptionsRequest_SessionOptionsEntry() {
    return { key: "", value: undefined };
}
export const SetSessionOptionsRequest_SessionOptionsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            SessionOptionValue.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetSessionOptionsRequest_SessionOptionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = SessionOptionValue.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return SetSessionOptionsRequest_SessionOptionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetSessionOptionsRequest_SessionOptionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? SessionOptionValue.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseSetSessionOptionsResult() {
    return { errors: {} };
}
export const SetSessionOptionsResult = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.errors).forEach(([key, value]) => {
            SetSessionOptionsResult_ErrorsEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetSessionOptionsResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = SetSessionOptionsResult_ErrorsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.errors[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return SetSessionOptionsResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetSessionOptionsResult();
        message.errors = Object.entries(object.errors ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = SetSessionOptionsResult_Error.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseSetSessionOptionsResult_Error() {
    return { value: 0 };
}
export const SetSessionOptionsResult_Error = {
    encode(message, writer = new BinaryWriter()) {
        if (message.value !== 0) {
            writer.uint32(8).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetSessionOptionsResult_Error();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.value = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return SetSessionOptionsResult_Error.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetSessionOptionsResult_Error();
        message.value = object.value ?? 0;
        return message;
    },
};
function createBaseSetSessionOptionsResult_ErrorsEntry() {
    return { key: "", value: undefined };
}
export const SetSessionOptionsResult_ErrorsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            SetSessionOptionsResult_Error.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetSessionOptionsResult_ErrorsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = SetSessionOptionsResult_Error.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return SetSessionOptionsResult_ErrorsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetSessionOptionsResult_ErrorsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? SetSessionOptionsResult_Error.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseGetSessionOptionsRequest() {
    return {};
}
export const GetSessionOptionsRequest = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSessionOptionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return GetSessionOptionsRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseGetSessionOptionsRequest();
        return message;
    },
};
function createBaseGetSessionOptionsResult() {
    return { sessionOptions: {} };
}
export const GetSessionOptionsResult = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.sessionOptions).forEach(([key, value]) => {
            GetSessionOptionsResult_SessionOptionsEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSessionOptionsResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = GetSessionOptionsResult_SessionOptionsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.sessionOptions[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return GetSessionOptionsResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetSessionOptionsResult();
        message.sessionOptions = Object.entries(object.sessionOptions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = SessionOptionValue.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseGetSessionOptionsResult_SessionOptionsEntry() {
    return { key: "", value: undefined };
}
export const GetSessionOptionsResult_SessionOptionsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            SessionOptionValue.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSessionOptionsResult_SessionOptionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = SessionOptionValue.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return GetSessionOptionsResult_SessionOptionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetSessionOptionsResult_SessionOptionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? SessionOptionValue.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseCloseSessionRequest() {
    return {};
}
export const CloseSessionRequest = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCloseSessionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CloseSessionRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseCloseSessionRequest();
        return message;
    },
};
function createBaseCloseSessionResult() {
    return { status: 0 };
}
export const CloseSessionResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.status !== 0) {
            writer.uint32(8).int32(message.status);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCloseSessionResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CloseSessionResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCloseSessionResult();
        message.status = object.status ?? 0;
        return message;
    },
};
export const FlightServiceDefinition = {
    name: "FlightService",
    fullName: "arrow.flight.protocol.FlightService",
    methods: {
        /**
         * Handshake between client and server. Depending on the server, the
         * handshake may be required to determine the token that should be used for
         * future operations. Both request and response are streams to allow multiple
         * round-trips depending on auth mechanism.
         */
        handshake: {
            name: "Handshake",
            requestType: HandshakeRequest,
            requestStream: true,
            responseType: HandshakeResponse,
            responseStream: true,
            options: {},
        },
        /**
         * Get a list of available streams given a particular criteria. Most flight
         * services will expose one or more streams that are readily available for
         * retrieval. This api allows listing the streams available for
         * consumption. A user can also provide a criteria. The criteria can limit
         * the subset of streams that can be listed via this interface. Each flight
         * service allows its own definition of how to consume criteria.
         */
        listFlights: {
            name: "ListFlights",
            requestType: Criteria,
            requestStream: false,
            responseType: FlightInfo,
            responseStream: true,
            options: {},
        },
        /**
         * For a given FlightDescriptor, get information about how the flight can be
         * consumed. This is a useful interface if the consumer of the interface
         * already can identify the specific flight to consume. This interface can
         * also allow a consumer to generate a flight stream through a specified
         * descriptor. For example, a flight descriptor might be something that
         * includes a SQL statement or a Pickled Python operation that will be
         * executed. In those cases, the descriptor will not be previously available
         * within the list of available streams provided by ListFlights but will be
         * available for consumption for the duration defined by the specific flight
         * service.
         */
        getFlightInfo: {
            name: "GetFlightInfo",
            requestType: FlightDescriptor,
            requestStream: false,
            responseType: FlightInfo,
            responseStream: false,
            options: {},
        },
        /**
         * For a given FlightDescriptor, start a query and get information
         * to poll its execution status. This is a useful interface if the
         * query may be a long-running query. The first PollFlightInfo call
         * should return as quickly as possible. (GetFlightInfo doesn't
         * return until the query is complete.)
         *
         * A client can consume any available results before
         * the query is completed. See PollInfo.info for details.
         *
         * A client can poll the updated query status by calling
         * PollFlightInfo() with PollInfo.flight_descriptor. A server
         * should not respond until the result would be different from last
         * time. That way, the client can "long poll" for updates
         * without constantly making requests. Clients can set a short timeout
         * to avoid blocking calls if desired.
         *
         * A client can't use PollInfo.flight_descriptor after
         * PollInfo.expiration_time passes. A server might not accept the
         * retry descriptor anymore and the query may be cancelled.
         *
         * A client may use the CancelFlightInfo action with
         * PollInfo.info to cancel the running query.
         */
        pollFlightInfo: {
            name: "PollFlightInfo",
            requestType: FlightDescriptor,
            requestStream: false,
            responseType: PollInfo,
            responseStream: false,
            options: {},
        },
        /**
         * For a given FlightDescriptor, get the Schema as described in Schema.fbs::Schema
         * This is used when a consumer needs the Schema of flight stream. Similar to
         * GetFlightInfo this interface may generate a new flight that was not previously
         * available in ListFlights.
         */
        getSchema: {
            name: "GetSchema",
            requestType: FlightDescriptor,
            requestStream: false,
            responseType: SchemaResult,
            responseStream: false,
            options: {},
        },
        /**
         * Retrieve a single stream associated with a particular descriptor
         * associated with the referenced ticket. A Flight can be composed of one or
         * more streams where each stream can be retrieved using a separate opaque
         * ticket that the flight service uses for managing a collection of streams.
         */
        doGet: {
            name: "DoGet",
            requestType: Ticket,
            requestStream: false,
            responseType: FlightData,
            responseStream: true,
            options: {},
        },
        /**
         * Push a stream to the flight service associated with a particular
         * flight stream. This allows a client of a flight service to upload a stream
         * of data. Depending on the particular flight service, a client consumer
         * could be allowed to upload a single stream per descriptor or an unlimited
         * number. In the latter, the service might implement a 'seal' action that
         * can be applied to a descriptor once all streams are uploaded.
         */
        doPut: {
            name: "DoPut",
            requestType: FlightData,
            requestStream: true,
            responseType: PutResult,
            responseStream: true,
            options: {},
        },
        /**
         * Open a bidirectional data channel for a given descriptor. This
         * allows clients to send and receive arbitrary Arrow data and
         * application-specific metadata in a single logical stream. In
         * contrast to DoGet/DoPut, this is more suited for clients
         * offloading computation (rather than storage) to a Flight service.
         */
        doExchange: {
            name: "DoExchange",
            requestType: FlightData,
            requestStream: true,
            responseType: FlightData,
            responseStream: true,
            options: {},
        },
        /**
         * Flight services can support an arbitrary number of simple actions in
         * addition to the possible ListFlights, GetFlightInfo, DoGet, DoPut
         * operations that are potentially available. DoAction allows a flight client
         * to do a specific action against a flight service. An action includes
         * opaque request and response objects that are specific to the type action
         * being undertaken.
         */
        doAction: {
            name: "DoAction",
            requestType: Action,
            requestStream: false,
            responseType: Result,
            responseStream: true,
            options: {},
        },
        /**
         * A flight service exposes all of the available action types that it has
         * along with descriptions. This allows different flight consumers to
         * understand the capabilities of the flight service.
         */
        listActions: {
            name: "ListActions",
            requestType: Empty,
            requestStream: false,
            responseType: ActionType,
            responseStream: true,
            options: {},
        },
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function longToNumber(int64) {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return num;
}
