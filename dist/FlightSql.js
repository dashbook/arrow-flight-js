// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: FlightSql.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
export const protobufPackage = "arrow.flight.protocol.sql";
/** Options for CommandGetSqlInfo. */
export var SqlInfo;
(function (SqlInfo) {
    /** FLIGHT_SQL_SERVER_NAME - Retrieves a UTF-8 string with the name of the Flight SQL Server. */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_NAME"] = 0] = "FLIGHT_SQL_SERVER_NAME";
    /** FLIGHT_SQL_SERVER_VERSION - Retrieves a UTF-8 string with the native version of the Flight SQL Server. */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_VERSION"] = 1] = "FLIGHT_SQL_SERVER_VERSION";
    /** FLIGHT_SQL_SERVER_ARROW_VERSION - Retrieves a UTF-8 string with the Arrow format version of the Flight SQL Server. */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_ARROW_VERSION"] = 2] = "FLIGHT_SQL_SERVER_ARROW_VERSION";
    /**
     * FLIGHT_SQL_SERVER_READ_ONLY - Retrieves a boolean value indicating whether the Flight SQL Server is read only.
     *
     * Returns:
     * - false: if read-write
     * - true: if read only
     */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_READ_ONLY"] = 3] = "FLIGHT_SQL_SERVER_READ_ONLY";
    /**
     * FLIGHT_SQL_SERVER_SQL - Retrieves a boolean value indicating whether the Flight SQL Server supports executing
     * SQL queries.
     *
     * Note that the absence of this info (as opposed to a false value) does not necessarily
     * mean that SQL is not supported, as this property was not originally defined.
     */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_SQL"] = 4] = "FLIGHT_SQL_SERVER_SQL";
    /**
     * FLIGHT_SQL_SERVER_SUBSTRAIT - Retrieves a boolean value indicating whether the Flight SQL Server supports executing
     * Substrait plans.
     */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_SUBSTRAIT"] = 5] = "FLIGHT_SQL_SERVER_SUBSTRAIT";
    /**
     * FLIGHT_SQL_SERVER_SUBSTRAIT_MIN_VERSION - Retrieves a string value indicating the minimum supported Substrait version, or null
     * if Substrait is not supported.
     */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_SUBSTRAIT_MIN_VERSION"] = 6] = "FLIGHT_SQL_SERVER_SUBSTRAIT_MIN_VERSION";
    /**
     * FLIGHT_SQL_SERVER_SUBSTRAIT_MAX_VERSION - Retrieves a string value indicating the maximum supported Substrait version, or null
     * if Substrait is not supported.
     */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_SUBSTRAIT_MAX_VERSION"] = 7] = "FLIGHT_SQL_SERVER_SUBSTRAIT_MAX_VERSION";
    /**
     * FLIGHT_SQL_SERVER_TRANSACTION - Retrieves an int32 indicating whether the Flight SQL Server supports the
     * BeginTransaction/EndTransaction/BeginSavepoint/EndSavepoint actions.
     *
     * Even if this is not supported, the database may still support explicit "BEGIN
     * TRANSACTION"/"COMMIT" SQL statements (see SQL_TRANSACTIONS_SUPPORTED); this property
     * is only about whether the server implements the Flight SQL API endpoints.
     *
     * The possible values are listed in `SqlSupportedTransaction`.
     */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_TRANSACTION"] = 8] = "FLIGHT_SQL_SERVER_TRANSACTION";
    /**
     * FLIGHT_SQL_SERVER_CANCEL - Retrieves a boolean value indicating whether the Flight SQL Server supports explicit
     * query cancellation (the CancelQuery action).
     */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_CANCEL"] = 9] = "FLIGHT_SQL_SERVER_CANCEL";
    /**
     * FLIGHT_SQL_SERVER_BULK_INGESTION - Retrieves a boolean value indicating whether the Flight SQL Server supports executing
     * bulk ingestion.
     */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_BULK_INGESTION"] = 10] = "FLIGHT_SQL_SERVER_BULK_INGESTION";
    /**
     * FLIGHT_SQL_SERVER_INGEST_TRANSACTIONS_SUPPORTED - Retrieves a boolean value indicating whether transactions are supported for bulk ingestion. If not, invoking
     * the method commit in the context of a bulk ingestion is a noop, and the isolation level is
     * `arrow.flight.protocol.sql.SqlTransactionIsolationLevel.TRANSACTION_NONE`.
     *
     * Returns:
     * - false: if bulk ingestion transactions are unsupported;
     * - true: if bulk ingestion transactions are supported.
     */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_INGEST_TRANSACTIONS_SUPPORTED"] = 11] = "FLIGHT_SQL_SERVER_INGEST_TRANSACTIONS_SUPPORTED";
    /**
     * FLIGHT_SQL_SERVER_STATEMENT_TIMEOUT - Retrieves an int32 indicating the timeout (in milliseconds) for prepared statement handles.
     *
     * If 0, there is no timeout.  Servers should reset the timeout when the handle is used in a command.
     */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_STATEMENT_TIMEOUT"] = 100] = "FLIGHT_SQL_SERVER_STATEMENT_TIMEOUT";
    /**
     * FLIGHT_SQL_SERVER_TRANSACTION_TIMEOUT - Retrieves an int32 indicating the timeout (in milliseconds) for transactions, since transactions are not tied to a connection.
     *
     * If 0, there is no timeout.  Servers should reset the timeout when the handle is used in a command.
     */
    SqlInfo[SqlInfo["FLIGHT_SQL_SERVER_TRANSACTION_TIMEOUT"] = 101] = "FLIGHT_SQL_SERVER_TRANSACTION_TIMEOUT";
    /**
     * SQL_DDL_CATALOG - Retrieves a boolean value indicating whether the Flight SQL Server supports CREATE and DROP of catalogs.
     *
     * Returns:
     * - false: if it doesn't support CREATE and DROP of catalogs.
     * - true: if it supports CREATE and DROP of catalogs.
     */
    SqlInfo[SqlInfo["SQL_DDL_CATALOG"] = 500] = "SQL_DDL_CATALOG";
    /**
     * SQL_DDL_SCHEMA - Retrieves a boolean value indicating whether the Flight SQL Server supports CREATE and DROP of schemas.
     *
     * Returns:
     * - false: if it doesn't support CREATE and DROP of schemas.
     * - true: if it supports CREATE and DROP of schemas.
     */
    SqlInfo[SqlInfo["SQL_DDL_SCHEMA"] = 501] = "SQL_DDL_SCHEMA";
    /**
     * SQL_DDL_TABLE - Indicates whether the Flight SQL Server supports CREATE and DROP of tables.
     *
     * Returns:
     * - false: if it doesn't support CREATE and DROP of tables.
     * - true: if it supports CREATE and DROP of tables.
     */
    SqlInfo[SqlInfo["SQL_DDL_TABLE"] = 502] = "SQL_DDL_TABLE";
    /**
     * SQL_IDENTIFIER_CASE - Retrieves a int32 ordinal representing the case sensitivity of catalog, table, schema and table names.
     *
     * The possible values are listed in `arrow.flight.protocol.sql.SqlSupportedCaseSensitivity`.
     */
    SqlInfo[SqlInfo["SQL_IDENTIFIER_CASE"] = 503] = "SQL_IDENTIFIER_CASE";
    /** SQL_IDENTIFIER_QUOTE_CHAR - Retrieves a UTF-8 string with the supported character(s) used to surround a delimited identifier. */
    SqlInfo[SqlInfo["SQL_IDENTIFIER_QUOTE_CHAR"] = 504] = "SQL_IDENTIFIER_QUOTE_CHAR";
    /**
     * SQL_QUOTED_IDENTIFIER_CASE - Retrieves a int32 describing the case sensitivity of quoted identifiers.
     *
     * The possible values are listed in `arrow.flight.protocol.sql.SqlSupportedCaseSensitivity`.
     */
    SqlInfo[SqlInfo["SQL_QUOTED_IDENTIFIER_CASE"] = 505] = "SQL_QUOTED_IDENTIFIER_CASE";
    /**
     * SQL_ALL_TABLES_ARE_SELECTABLE - Retrieves a boolean value indicating whether all tables are selectable.
     *
     * Returns:
     * - false: if not all tables are selectable or if none are;
     * - true: if all tables are selectable.
     */
    SqlInfo[SqlInfo["SQL_ALL_TABLES_ARE_SELECTABLE"] = 506] = "SQL_ALL_TABLES_ARE_SELECTABLE";
    /**
     * SQL_NULL_ORDERING - Retrieves the null ordering.
     *
     * Returns a int32 ordinal for the null ordering being used, as described in
     * `arrow.flight.protocol.sql.SqlNullOrdering`.
     */
    SqlInfo[SqlInfo["SQL_NULL_ORDERING"] = 507] = "SQL_NULL_ORDERING";
    /** SQL_KEYWORDS - Retrieves a UTF-8 string list with values of the supported keywords. */
    SqlInfo[SqlInfo["SQL_KEYWORDS"] = 508] = "SQL_KEYWORDS";
    /** SQL_NUMERIC_FUNCTIONS - Retrieves a UTF-8 string list with values of the supported numeric functions. */
    SqlInfo[SqlInfo["SQL_NUMERIC_FUNCTIONS"] = 509] = "SQL_NUMERIC_FUNCTIONS";
    /** SQL_STRING_FUNCTIONS - Retrieves a UTF-8 string list with values of the supported string functions. */
    SqlInfo[SqlInfo["SQL_STRING_FUNCTIONS"] = 510] = "SQL_STRING_FUNCTIONS";
    /** SQL_SYSTEM_FUNCTIONS - Retrieves a UTF-8 string list with values of the supported system functions. */
    SqlInfo[SqlInfo["SQL_SYSTEM_FUNCTIONS"] = 511] = "SQL_SYSTEM_FUNCTIONS";
    /** SQL_DATETIME_FUNCTIONS - Retrieves a UTF-8 string list with values of the supported datetime functions. */
    SqlInfo[SqlInfo["SQL_DATETIME_FUNCTIONS"] = 512] = "SQL_DATETIME_FUNCTIONS";
    /**
     * SQL_SEARCH_STRING_ESCAPE - Retrieves the UTF-8 string that can be used to escape wildcard characters.
     * This is the string that can be used to escape '_' or '%' in the catalog search parameters that are a pattern
     * (and therefore use one of the wildcard characters).
     * The '_' character represents any single character; the '%' character represents any sequence of zero or more
     * characters.
     */
    SqlInfo[SqlInfo["SQL_SEARCH_STRING_ESCAPE"] = 513] = "SQL_SEARCH_STRING_ESCAPE";
    /**
     * SQL_EXTRA_NAME_CHARACTERS - Retrieves a UTF-8 string with all the "extra" characters that can be used in unquoted identifier names
     * (those beyond a-z, A-Z, 0-9 and _).
     */
    SqlInfo[SqlInfo["SQL_EXTRA_NAME_CHARACTERS"] = 514] = "SQL_EXTRA_NAME_CHARACTERS";
    /**
     * SQL_SUPPORTS_COLUMN_ALIASING - Retrieves a boolean value indicating whether column aliasing is supported.
     * If so, the SQL AS clause can be used to provide names for computed columns or to provide alias names for columns
     * as required.
     *
     * Returns:
     * - false: if column aliasing is unsupported;
     * - true: if column aliasing is supported.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTS_COLUMN_ALIASING"] = 515] = "SQL_SUPPORTS_COLUMN_ALIASING";
    /**
     * SQL_NULL_PLUS_NULL_IS_NULL - Retrieves a boolean value indicating whether concatenations between null and non-null values being
     * null are supported.
     *
     * - Returns:
     * - false: if concatenations between null and non-null values being null are unsupported;
     * - true: if concatenations between null and non-null values being null are supported.
     */
    SqlInfo[SqlInfo["SQL_NULL_PLUS_NULL_IS_NULL"] = 516] = "SQL_NULL_PLUS_NULL_IS_NULL";
    /**
     * SQL_SUPPORTS_CONVERT - Retrieves a map where the key is the type to convert from and the value is a list with the types to convert to,
     * indicating the supported conversions. Each key and each item on the list value is a value to a predefined type on
     * SqlSupportsConvert enum.
     * The returned map will be:  map<int32, list<int32>>
     */
    SqlInfo[SqlInfo["SQL_SUPPORTS_CONVERT"] = 517] = "SQL_SUPPORTS_CONVERT";
    /**
     * SQL_SUPPORTS_TABLE_CORRELATION_NAMES - Retrieves a boolean value indicating whether, when table correlation names are supported,
     * they are restricted to being different from the names of the tables.
     *
     * Returns:
     * - false: if table correlation names are unsupported;
     * - true: if table correlation names are supported.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTS_TABLE_CORRELATION_NAMES"] = 518] = "SQL_SUPPORTS_TABLE_CORRELATION_NAMES";
    /**
     * SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES - Retrieves a boolean value indicating whether, when table correlation names are supported,
     * they are restricted to being different from the names of the tables.
     *
     * Returns:
     * - false: if different table correlation names are unsupported;
     * - true: if different table correlation names are supported
     */
    SqlInfo[SqlInfo["SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES"] = 519] = "SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES";
    /**
     * SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY - Retrieves a boolean value indicating whether expressions in ORDER BY lists are supported.
     *
     * Returns:
     * - false: if expressions in ORDER BY are unsupported;
     * - true: if expressions in ORDER BY are supported;
     */
    SqlInfo[SqlInfo["SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY"] = 520] = "SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY";
    /**
     * SQL_SUPPORTS_ORDER_BY_UNRELATED - Retrieves a boolean value indicating whether using a column that is not in the SELECT statement in a GROUP BY
     * clause is supported.
     *
     * Returns:
     * - false: if using a column that is not in the SELECT statement in a GROUP BY clause is unsupported;
     * - true: if using a column that is not in the SELECT statement in a GROUP BY clause is supported.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTS_ORDER_BY_UNRELATED"] = 521] = "SQL_SUPPORTS_ORDER_BY_UNRELATED";
    /**
     * SQL_SUPPORTED_GROUP_BY - Retrieves the supported GROUP BY commands;
     *
     * Returns an int32 bitmask value representing the supported commands.
     * The returned bitmask should be parsed in order to retrieve the supported commands.
     *
     * For instance:
     * - return 0 (\b0)   => [] (GROUP BY is unsupported);
     * - return 1 (\b1)   => [SQL_GROUP_BY_UNRELATED];
     * - return 2 (\b10)  => [SQL_GROUP_BY_BEYOND_SELECT];
     * - return 3 (\b11)  => [SQL_GROUP_BY_UNRELATED, SQL_GROUP_BY_BEYOND_SELECT].
     * Valid GROUP BY types are described under `arrow.flight.protocol.sql.SqlSupportedGroupBy`.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTED_GROUP_BY"] = 522] = "SQL_SUPPORTED_GROUP_BY";
    /**
     * SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE - Retrieves a boolean value indicating whether specifying a LIKE escape clause is supported.
     *
     * Returns:
     * - false: if specifying a LIKE escape clause is unsupported;
     * - true: if specifying a LIKE escape clause is supported.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE"] = 523] = "SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE";
    /**
     * SQL_SUPPORTS_NON_NULLABLE_COLUMNS - Retrieves a boolean value indicating whether columns may be defined as non-nullable.
     *
     * Returns:
     * - false: if columns cannot be defined as non-nullable;
     * - true: if columns may be defined as non-nullable.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTS_NON_NULLABLE_COLUMNS"] = 524] = "SQL_SUPPORTS_NON_NULLABLE_COLUMNS";
    /**
     * SQL_SUPPORTED_GRAMMAR - Retrieves the supported SQL grammar level as per the ODBC specification.
     *
     * Returns an int32 bitmask value representing the supported SQL grammar level.
     * The returned bitmask should be parsed in order to retrieve the supported grammar levels.
     *
     * For instance:
     * - return 0 (\b0)   => [] (SQL grammar is unsupported);
     * - return 1 (\b1)   => [SQL_MINIMUM_GRAMMAR];
     * - return 2 (\b10)  => [SQL_CORE_GRAMMAR];
     * - return 3 (\b11)  => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR];
     * - return 4 (\b100) => [SQL_EXTENDED_GRAMMAR];
     * - return 5 (\b101) => [SQL_MINIMUM_GRAMMAR, SQL_EXTENDED_GRAMMAR];
     * - return 6 (\b110) => [SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR];
     * - return 7 (\b111) => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR].
     * Valid SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedSqlGrammar`.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTED_GRAMMAR"] = 525] = "SQL_SUPPORTED_GRAMMAR";
    /**
     * SQL_ANSI92_SUPPORTED_LEVEL - Retrieves the supported ANSI92 SQL grammar level.
     *
     * Returns an int32 bitmask value representing the supported ANSI92 SQL grammar level.
     * The returned bitmask should be parsed in order to retrieve the supported commands.
     *
     * For instance:
     * - return 0 (\b0)   => [] (ANSI92 SQL grammar is unsupported);
     * - return 1 (\b1)   => [ANSI92_ENTRY_SQL];
     * - return 2 (\b10)  => [ANSI92_INTERMEDIATE_SQL];
     * - return 3 (\b11)  => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL];
     * - return 4 (\b100) => [ANSI92_FULL_SQL];
     * - return 5 (\b101) => [ANSI92_ENTRY_SQL, ANSI92_FULL_SQL];
     * - return 6 (\b110) => [ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL];
     * - return 7 (\b111) => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL].
     * Valid ANSI92 SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedAnsi92SqlGrammarLevel`.
     */
    SqlInfo[SqlInfo["SQL_ANSI92_SUPPORTED_LEVEL"] = 526] = "SQL_ANSI92_SUPPORTED_LEVEL";
    /**
     * SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY - Retrieves a boolean value indicating whether the SQL Integrity Enhancement Facility is supported.
     *
     * Returns:
     * - false: if the SQL Integrity Enhancement Facility is supported;
     * - true: if the SQL Integrity Enhancement Facility is supported.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY"] = 527] = "SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY";
    /**
     * SQL_OUTER_JOINS_SUPPORT_LEVEL - Retrieves the support level for SQL OUTER JOINs.
     *
     * Returns a int32 ordinal for the SQL ordering being used, as described in
     * `arrow.flight.protocol.sql.SqlOuterJoinsSupportLevel`.
     */
    SqlInfo[SqlInfo["SQL_OUTER_JOINS_SUPPORT_LEVEL"] = 528] = "SQL_OUTER_JOINS_SUPPORT_LEVEL";
    /** SQL_SCHEMA_TERM - Retrieves a UTF-8 string with the preferred term for "schema". */
    SqlInfo[SqlInfo["SQL_SCHEMA_TERM"] = 529] = "SQL_SCHEMA_TERM";
    /** SQL_PROCEDURE_TERM - Retrieves a UTF-8 string with the preferred term for "procedure". */
    SqlInfo[SqlInfo["SQL_PROCEDURE_TERM"] = 530] = "SQL_PROCEDURE_TERM";
    /**
     * SQL_CATALOG_TERM - Retrieves a UTF-8 string with the preferred term for "catalog".
     * If a empty string is returned its assumed that the server does NOT supports catalogs.
     */
    SqlInfo[SqlInfo["SQL_CATALOG_TERM"] = 531] = "SQL_CATALOG_TERM";
    /**
     * SQL_CATALOG_AT_START - Retrieves a boolean value indicating whether a catalog appears at the start of a fully qualified table name.
     *
     * - false: if a catalog does not appear at the start of a fully qualified table name;
     * - true: if a catalog appears at the start of a fully qualified table name.
     */
    SqlInfo[SqlInfo["SQL_CATALOG_AT_START"] = 532] = "SQL_CATALOG_AT_START";
    /**
     * SQL_SCHEMAS_SUPPORTED_ACTIONS - Retrieves the supported actions for a SQL schema.
     *
     * Returns an int32 bitmask value representing the supported actions for a SQL schema.
     * The returned bitmask should be parsed in order to retrieve the supported actions for a SQL schema.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported actions for SQL schema);
     * - return 1 (\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
     * - return 2 (\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
     * - return 3 (\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
     * - return 4 (\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
     * - return 5 (\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
     * - return 6 (\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
     * - return 7 (\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
     * Valid actions for a SQL schema described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
     */
    SqlInfo[SqlInfo["SQL_SCHEMAS_SUPPORTED_ACTIONS"] = 533] = "SQL_SCHEMAS_SUPPORTED_ACTIONS";
    /**
     * SQL_CATALOGS_SUPPORTED_ACTIONS - Retrieves the supported actions for a SQL schema.
     *
     * Returns an int32 bitmask value representing the supported actions for a SQL catalog.
     * The returned bitmask should be parsed in order to retrieve the supported actions for a SQL catalog.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported actions for SQL catalog);
     * - return 1 (\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
     * - return 2 (\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
     * - return 3 (\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
     * - return 4 (\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
     * - return 5 (\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
     * - return 6 (\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
     * - return 7 (\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
     * Valid actions for a SQL catalog are described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
     */
    SqlInfo[SqlInfo["SQL_CATALOGS_SUPPORTED_ACTIONS"] = 534] = "SQL_CATALOGS_SUPPORTED_ACTIONS";
    /**
     * SQL_SUPPORTED_POSITIONED_COMMANDS - Retrieves the supported SQL positioned commands.
     *
     * Returns an int32 bitmask value representing the supported SQL positioned commands.
     * The returned bitmask should be parsed in order to retrieve the supported SQL positioned commands.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported SQL positioned commands);
     * - return 1 (\b1)   => [SQL_POSITIONED_DELETE];
     * - return 2 (\b10)  => [SQL_POSITIONED_UPDATE];
     * - return 3 (\b11)  => [SQL_POSITIONED_DELETE, SQL_POSITIONED_UPDATE].
     * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedPositionedCommands`.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTED_POSITIONED_COMMANDS"] = 535] = "SQL_SUPPORTED_POSITIONED_COMMANDS";
    /**
     * SQL_SELECT_FOR_UPDATE_SUPPORTED - Retrieves a boolean value indicating whether SELECT FOR UPDATE statements are supported.
     *
     * Returns:
     * - false: if SELECT FOR UPDATE statements are unsupported;
     * - true: if SELECT FOR UPDATE statements are supported.
     */
    SqlInfo[SqlInfo["SQL_SELECT_FOR_UPDATE_SUPPORTED"] = 536] = "SQL_SELECT_FOR_UPDATE_SUPPORTED";
    /**
     * SQL_STORED_PROCEDURES_SUPPORTED - Retrieves a boolean value indicating whether stored procedure calls that use the stored procedure escape syntax
     * are supported.
     *
     * Returns:
     * - false: if stored procedure calls that use the stored procedure escape syntax are unsupported;
     * - true: if stored procedure calls that use the stored procedure escape syntax are supported.
     */
    SqlInfo[SqlInfo["SQL_STORED_PROCEDURES_SUPPORTED"] = 537] = "SQL_STORED_PROCEDURES_SUPPORTED";
    /**
     * SQL_SUPPORTED_SUBQUERIES - Retrieves the supported SQL subqueries.
     *
     * Returns an int32 bitmask value representing the supported SQL subqueries.
     * The returned bitmask should be parsed in order to retrieve the supported SQL subqueries.
     *
     * For instance:
     * - return 0   (\b0)     => [] (no supported SQL subqueries);
     * - return 1   (\b1)     => [SQL_SUBQUERIES_IN_COMPARISONS];
     * - return 2   (\b10)    => [SQL_SUBQUERIES_IN_EXISTS];
     * - return 3   (\b11)    => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS];
     * - return 4   (\b100)   => [SQL_SUBQUERIES_IN_INS];
     * - return 5   (\b101)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS];
     * - return 6   (\b110)   => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_EXISTS];
     * - return 7   (\b111)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS];
     * - return 8   (\b1000)  => [SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 9   (\b1001)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 10  (\b1010)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 11  (\b1011)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 12  (\b1100)  => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 13  (\b1101)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 14  (\b1110)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 15  (\b1111)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - ...
     * Valid SQL subqueries are described under `arrow.flight.protocol.sql.SqlSupportedSubqueries`.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTED_SUBQUERIES"] = 538] = "SQL_SUPPORTED_SUBQUERIES";
    /**
     * SQL_CORRELATED_SUBQUERIES_SUPPORTED - Retrieves a boolean value indicating whether correlated subqueries are supported.
     *
     * Returns:
     * - false: if correlated subqueries are unsupported;
     * - true: if correlated subqueries are supported.
     */
    SqlInfo[SqlInfo["SQL_CORRELATED_SUBQUERIES_SUPPORTED"] = 539] = "SQL_CORRELATED_SUBQUERIES_SUPPORTED";
    /**
     * SQL_SUPPORTED_UNIONS - Retrieves the supported SQL UNIONs.
     *
     * Returns an int32 bitmask value representing the supported SQL UNIONs.
     * The returned bitmask should be parsed in order to retrieve the supported SQL UNIONs.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported SQL positioned commands);
     * - return 1 (\b1)   => [SQL_UNION];
     * - return 2 (\b10)  => [SQL_UNION_ALL];
     * - return 3 (\b11)  => [SQL_UNION, SQL_UNION_ALL].
     * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedUnions`.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTED_UNIONS"] = 540] = "SQL_SUPPORTED_UNIONS";
    /** SQL_MAX_BINARY_LITERAL_LENGTH - Retrieves a int64 value representing the maximum number of hex characters allowed in an inline binary literal. */
    SqlInfo[SqlInfo["SQL_MAX_BINARY_LITERAL_LENGTH"] = 541] = "SQL_MAX_BINARY_LITERAL_LENGTH";
    /** SQL_MAX_CHAR_LITERAL_LENGTH - Retrieves a int64 value representing the maximum number of characters allowed for a character literal. */
    SqlInfo[SqlInfo["SQL_MAX_CHAR_LITERAL_LENGTH"] = 542] = "SQL_MAX_CHAR_LITERAL_LENGTH";
    /** SQL_MAX_COLUMN_NAME_LENGTH - Retrieves a int64 value representing the maximum number of characters allowed for a column name. */
    SqlInfo[SqlInfo["SQL_MAX_COLUMN_NAME_LENGTH"] = 543] = "SQL_MAX_COLUMN_NAME_LENGTH";
    /** SQL_MAX_COLUMNS_IN_GROUP_BY - Retrieves a int64 value representing the maximum number of columns allowed in a GROUP BY clause. */
    SqlInfo[SqlInfo["SQL_MAX_COLUMNS_IN_GROUP_BY"] = 544] = "SQL_MAX_COLUMNS_IN_GROUP_BY";
    /** SQL_MAX_COLUMNS_IN_INDEX - Retrieves a int64 value representing the maximum number of columns allowed in an index. */
    SqlInfo[SqlInfo["SQL_MAX_COLUMNS_IN_INDEX"] = 545] = "SQL_MAX_COLUMNS_IN_INDEX";
    /** SQL_MAX_COLUMNS_IN_ORDER_BY - Retrieves a int64 value representing the maximum number of columns allowed in an ORDER BY clause. */
    SqlInfo[SqlInfo["SQL_MAX_COLUMNS_IN_ORDER_BY"] = 546] = "SQL_MAX_COLUMNS_IN_ORDER_BY";
    /** SQL_MAX_COLUMNS_IN_SELECT - Retrieves a int64 value representing the maximum number of columns allowed in a SELECT list. */
    SqlInfo[SqlInfo["SQL_MAX_COLUMNS_IN_SELECT"] = 547] = "SQL_MAX_COLUMNS_IN_SELECT";
    /** SQL_MAX_COLUMNS_IN_TABLE - Retrieves a int64 value representing the maximum number of columns allowed in a table. */
    SqlInfo[SqlInfo["SQL_MAX_COLUMNS_IN_TABLE"] = 548] = "SQL_MAX_COLUMNS_IN_TABLE";
    /** SQL_MAX_CONNECTIONS - Retrieves a int64 value representing the maximum number of concurrent connections possible. */
    SqlInfo[SqlInfo["SQL_MAX_CONNECTIONS"] = 549] = "SQL_MAX_CONNECTIONS";
    /** SQL_MAX_CURSOR_NAME_LENGTH - Retrieves a int64 value the maximum number of characters allowed in a cursor name. */
    SqlInfo[SqlInfo["SQL_MAX_CURSOR_NAME_LENGTH"] = 550] = "SQL_MAX_CURSOR_NAME_LENGTH";
    /**
     * SQL_MAX_INDEX_LENGTH - Retrieves a int64 value representing the maximum number of bytes allowed for an index,
     * including all of the parts of the index.
     */
    SqlInfo[SqlInfo["SQL_MAX_INDEX_LENGTH"] = 551] = "SQL_MAX_INDEX_LENGTH";
    /** SQL_DB_SCHEMA_NAME_LENGTH - Retrieves a int64 value representing the maximum number of characters allowed in a schema name. */
    SqlInfo[SqlInfo["SQL_DB_SCHEMA_NAME_LENGTH"] = 552] = "SQL_DB_SCHEMA_NAME_LENGTH";
    /** SQL_MAX_PROCEDURE_NAME_LENGTH - Retrieves a int64 value representing the maximum number of characters allowed in a procedure name. */
    SqlInfo[SqlInfo["SQL_MAX_PROCEDURE_NAME_LENGTH"] = 553] = "SQL_MAX_PROCEDURE_NAME_LENGTH";
    /** SQL_MAX_CATALOG_NAME_LENGTH - Retrieves a int64 value representing the maximum number of characters allowed in a catalog name. */
    SqlInfo[SqlInfo["SQL_MAX_CATALOG_NAME_LENGTH"] = 554] = "SQL_MAX_CATALOG_NAME_LENGTH";
    /** SQL_MAX_ROW_SIZE - Retrieves a int64 value representing the maximum number of bytes allowed in a single row. */
    SqlInfo[SqlInfo["SQL_MAX_ROW_SIZE"] = 555] = "SQL_MAX_ROW_SIZE";
    /**
     * SQL_MAX_ROW_SIZE_INCLUDES_BLOBS - Retrieves a boolean indicating whether the return value for the JDBC method getMaxRowSize includes the SQL
     * data types LONGVARCHAR and LONGVARBINARY.
     *
     * Returns:
     * - false: if return value for the JDBC method getMaxRowSize does
     *          not include the SQL data types LONGVARCHAR and LONGVARBINARY;
     * - true: if return value for the JDBC method getMaxRowSize includes
     *         the SQL data types LONGVARCHAR and LONGVARBINARY.
     */
    SqlInfo[SqlInfo["SQL_MAX_ROW_SIZE_INCLUDES_BLOBS"] = 556] = "SQL_MAX_ROW_SIZE_INCLUDES_BLOBS";
    /**
     * SQL_MAX_STATEMENT_LENGTH - Retrieves a int64 value representing the maximum number of characters allowed for an SQL statement;
     * a result of 0 (zero) means that there is no limit or the limit is not known.
     */
    SqlInfo[SqlInfo["SQL_MAX_STATEMENT_LENGTH"] = 557] = "SQL_MAX_STATEMENT_LENGTH";
    /** SQL_MAX_STATEMENTS - Retrieves a int64 value representing the maximum number of active statements that can be open at the same time. */
    SqlInfo[SqlInfo["SQL_MAX_STATEMENTS"] = 558] = "SQL_MAX_STATEMENTS";
    /** SQL_MAX_TABLE_NAME_LENGTH - Retrieves a int64 value representing the maximum number of characters allowed in a table name. */
    SqlInfo[SqlInfo["SQL_MAX_TABLE_NAME_LENGTH"] = 559] = "SQL_MAX_TABLE_NAME_LENGTH";
    /** SQL_MAX_TABLES_IN_SELECT - Retrieves a int64 value representing the maximum number of tables allowed in a SELECT statement. */
    SqlInfo[SqlInfo["SQL_MAX_TABLES_IN_SELECT"] = 560] = "SQL_MAX_TABLES_IN_SELECT";
    /** SQL_MAX_USERNAME_LENGTH - Retrieves a int64 value representing the maximum number of characters allowed in a user name. */
    SqlInfo[SqlInfo["SQL_MAX_USERNAME_LENGTH"] = 561] = "SQL_MAX_USERNAME_LENGTH";
    /**
     * SQL_DEFAULT_TRANSACTION_ISOLATION - Retrieves this database's default transaction isolation level as described in
     * `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.
     *
     * Returns a int32 ordinal for the SQL transaction isolation level.
     */
    SqlInfo[SqlInfo["SQL_DEFAULT_TRANSACTION_ISOLATION"] = 562] = "SQL_DEFAULT_TRANSACTION_ISOLATION";
    /**
     * SQL_TRANSACTIONS_SUPPORTED - Retrieves a boolean value indicating whether transactions are supported. If not, invoking the method commit is a
     * noop, and the isolation level is `arrow.flight.protocol.sql.SqlTransactionIsolationLevel.TRANSACTION_NONE`.
     *
     * Returns:
     * - false: if transactions are unsupported;
     * - true: if transactions are supported.
     */
    SqlInfo[SqlInfo["SQL_TRANSACTIONS_SUPPORTED"] = 563] = "SQL_TRANSACTIONS_SUPPORTED";
    /**
     * SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS - Retrieves the supported transactions isolation levels.
     *
     * Returns an int32 bitmask value representing the supported transactions isolation levels.
     * The returned bitmask should be parsed in order to retrieve the supported transactions isolation levels.
     *
     * For instance:
     * - return 0   (\b0)     => [] (no supported SQL transactions isolation levels);
     * - return 1   (\b1)     => [SQL_TRANSACTION_NONE];
     * - return 2   (\b10)    => [SQL_TRANSACTION_READ_UNCOMMITTED];
     * - return 3   (\b11)    => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED];
     * - return 4   (\b100)   => [SQL_TRANSACTION_REPEATABLE_READ];
     * - return 5   (\b101)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 6   (\b110)   => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 7   (\b111)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 8   (\b1000)  => [SQL_TRANSACTION_REPEATABLE_READ];
     * - return 9   (\b1001)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 10  (\b1010)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 11  (\b1011)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 12  (\b1100)  => [SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 13  (\b1101)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 14  (\b1110)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 15  (\b1111)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 16  (\b10000) => [SQL_TRANSACTION_SERIALIZABLE];
     * - ...
     * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS"] = 564] = "SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS";
    /**
     * SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT - Retrieves a boolean value indicating whether a data definition statement within a transaction forces
     * the transaction to commit.
     *
     * Returns:
     * - false: if a data definition statement within a transaction does not force the transaction to commit;
     * - true: if a data definition statement within a transaction forces the transaction to commit.
     */
    SqlInfo[SqlInfo["SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT"] = 565] = "SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT";
    /**
     * SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED - Retrieves a boolean value indicating whether a data definition statement within a transaction is ignored.
     *
     * Returns:
     * - false: if a data definition statement within a transaction is taken into account;
     * - true: a data definition statement within a transaction is ignored.
     */
    SqlInfo[SqlInfo["SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED"] = 566] = "SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED";
    /**
     * SQL_SUPPORTED_RESULT_SET_TYPES - Retrieves an int32 bitmask value representing the supported result set types.
     * The returned bitmask should be parsed in order to retrieve the supported result set types.
     *
     * For instance:
     * - return 0   (\b0)     => [] (no supported result set types);
     * - return 1   (\b1)     => [SQL_RESULT_SET_TYPE_UNSPECIFIED];
     * - return 2   (\b10)    => [SQL_RESULT_SET_TYPE_FORWARD_ONLY];
     * - return 3   (\b11)    => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY];
     * - return 4   (\b100)   => [SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
     * - return 5   (\b101)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
     * - return 6   (\b110)   => [SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
     * - return 7   (\b111)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
     * - return 8   (\b1000)  => [SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE];
     * - ...
     * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetType`.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTED_RESULT_SET_TYPES"] = 567] = "SQL_SUPPORTED_RESULT_SET_TYPES";
    /**
     * SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED - Returns an int32 bitmask value concurrency types supported for
     * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_UNSPECIFIED`.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
     * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
     * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED"] = 568] = "SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED";
    /**
     * SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY - Returns an int32 bitmask value concurrency types supported for
     * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_FORWARD_ONLY`.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
     * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
     * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY"] = 569] = "SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY";
    /**
     * SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE - Returns an int32 bitmask value concurrency types supported for
     * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE`.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
     * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
     * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE"] = 570] = "SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE";
    /**
     * SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE - Returns an int32 bitmask value concurrency types supported for
     * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE`.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
     * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
     * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
     */
    SqlInfo[SqlInfo["SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE"] = 571] = "SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE";
    /**
     * SQL_BATCH_UPDATES_SUPPORTED - Retrieves a boolean value indicating whether this database supports batch updates.
     *
     * - false: if this database does not support batch updates;
     * - true: if this database supports batch updates.
     */
    SqlInfo[SqlInfo["SQL_BATCH_UPDATES_SUPPORTED"] = 572] = "SQL_BATCH_UPDATES_SUPPORTED";
    /**
     * SQL_SAVEPOINTS_SUPPORTED - Retrieves a boolean value indicating whether this database supports savepoints.
     *
     * Returns:
     * - false: if this database does not support savepoints;
     * - true: if this database supports savepoints.
     */
    SqlInfo[SqlInfo["SQL_SAVEPOINTS_SUPPORTED"] = 573] = "SQL_SAVEPOINTS_SUPPORTED";
    /**
     * SQL_NAMED_PARAMETERS_SUPPORTED - Retrieves a boolean value indicating whether named parameters are supported in callable statements.
     *
     * Returns:
     * - false: if named parameters in callable statements are unsupported;
     * - true: if named parameters in callable statements are supported.
     */
    SqlInfo[SqlInfo["SQL_NAMED_PARAMETERS_SUPPORTED"] = 574] = "SQL_NAMED_PARAMETERS_SUPPORTED";
    /**
     * SQL_LOCATORS_UPDATE_COPY - Retrieves a boolean value indicating whether updates made to a LOB are made on a copy or directly to the LOB.
     *
     * Returns:
     * - false: if updates made to a LOB are made directly to the LOB;
     * - true: if updates made to a LOB are made on a copy.
     */
    SqlInfo[SqlInfo["SQL_LOCATORS_UPDATE_COPY"] = 575] = "SQL_LOCATORS_UPDATE_COPY";
    /**
     * SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED - Retrieves a boolean value indicating whether invoking user-defined or vendor functions
     * using the stored procedure escape syntax is supported.
     *
     * Returns:
     * - false: if invoking user-defined or vendor functions using the stored procedure escape syntax is unsupported;
     * - true: if invoking user-defined or vendor functions using the stored procedure escape syntax is supported.
     */
    SqlInfo[SqlInfo["SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED"] = 576] = "SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED";
    SqlInfo[SqlInfo["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlInfo || (SqlInfo = {}));
/** The level of support for Flight SQL transaction RPCs. */
export var SqlSupportedTransaction;
(function (SqlSupportedTransaction) {
    /** SQL_SUPPORTED_TRANSACTION_NONE - Unknown/not indicated/no support */
    SqlSupportedTransaction[SqlSupportedTransaction["SQL_SUPPORTED_TRANSACTION_NONE"] = 0] = "SQL_SUPPORTED_TRANSACTION_NONE";
    /**
     * SQL_SUPPORTED_TRANSACTION_TRANSACTION - Transactions, but not savepoints.
     * A savepoint is a mark within a transaction that can be individually
     * rolled back to. Not all databases support savepoints.
     */
    SqlSupportedTransaction[SqlSupportedTransaction["SQL_SUPPORTED_TRANSACTION_TRANSACTION"] = 1] = "SQL_SUPPORTED_TRANSACTION_TRANSACTION";
    /** SQL_SUPPORTED_TRANSACTION_SAVEPOINT - Transactions and savepoints */
    SqlSupportedTransaction[SqlSupportedTransaction["SQL_SUPPORTED_TRANSACTION_SAVEPOINT"] = 2] = "SQL_SUPPORTED_TRANSACTION_SAVEPOINT";
    SqlSupportedTransaction[SqlSupportedTransaction["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlSupportedTransaction || (SqlSupportedTransaction = {}));
export var SqlSupportedCaseSensitivity;
(function (SqlSupportedCaseSensitivity) {
    SqlSupportedCaseSensitivity[SqlSupportedCaseSensitivity["SQL_CASE_SENSITIVITY_UNKNOWN"] = 0] = "SQL_CASE_SENSITIVITY_UNKNOWN";
    SqlSupportedCaseSensitivity[SqlSupportedCaseSensitivity["SQL_CASE_SENSITIVITY_CASE_INSENSITIVE"] = 1] = "SQL_CASE_SENSITIVITY_CASE_INSENSITIVE";
    SqlSupportedCaseSensitivity[SqlSupportedCaseSensitivity["SQL_CASE_SENSITIVITY_UPPERCASE"] = 2] = "SQL_CASE_SENSITIVITY_UPPERCASE";
    SqlSupportedCaseSensitivity[SqlSupportedCaseSensitivity["SQL_CASE_SENSITIVITY_LOWERCASE"] = 3] = "SQL_CASE_SENSITIVITY_LOWERCASE";
    SqlSupportedCaseSensitivity[SqlSupportedCaseSensitivity["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlSupportedCaseSensitivity || (SqlSupportedCaseSensitivity = {}));
export var SqlNullOrdering;
(function (SqlNullOrdering) {
    SqlNullOrdering[SqlNullOrdering["SQL_NULLS_SORTED_HIGH"] = 0] = "SQL_NULLS_SORTED_HIGH";
    SqlNullOrdering[SqlNullOrdering["SQL_NULLS_SORTED_LOW"] = 1] = "SQL_NULLS_SORTED_LOW";
    SqlNullOrdering[SqlNullOrdering["SQL_NULLS_SORTED_AT_START"] = 2] = "SQL_NULLS_SORTED_AT_START";
    SqlNullOrdering[SqlNullOrdering["SQL_NULLS_SORTED_AT_END"] = 3] = "SQL_NULLS_SORTED_AT_END";
    SqlNullOrdering[SqlNullOrdering["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlNullOrdering || (SqlNullOrdering = {}));
export var SupportedSqlGrammar;
(function (SupportedSqlGrammar) {
    SupportedSqlGrammar[SupportedSqlGrammar["SQL_MINIMUM_GRAMMAR"] = 0] = "SQL_MINIMUM_GRAMMAR";
    SupportedSqlGrammar[SupportedSqlGrammar["SQL_CORE_GRAMMAR"] = 1] = "SQL_CORE_GRAMMAR";
    SupportedSqlGrammar[SupportedSqlGrammar["SQL_EXTENDED_GRAMMAR"] = 2] = "SQL_EXTENDED_GRAMMAR";
    SupportedSqlGrammar[SupportedSqlGrammar["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SupportedSqlGrammar || (SupportedSqlGrammar = {}));
export var SupportedAnsi92SqlGrammarLevel;
(function (SupportedAnsi92SqlGrammarLevel) {
    SupportedAnsi92SqlGrammarLevel[SupportedAnsi92SqlGrammarLevel["ANSI92_ENTRY_SQL"] = 0] = "ANSI92_ENTRY_SQL";
    SupportedAnsi92SqlGrammarLevel[SupportedAnsi92SqlGrammarLevel["ANSI92_INTERMEDIATE_SQL"] = 1] = "ANSI92_INTERMEDIATE_SQL";
    SupportedAnsi92SqlGrammarLevel[SupportedAnsi92SqlGrammarLevel["ANSI92_FULL_SQL"] = 2] = "ANSI92_FULL_SQL";
    SupportedAnsi92SqlGrammarLevel[SupportedAnsi92SqlGrammarLevel["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SupportedAnsi92SqlGrammarLevel || (SupportedAnsi92SqlGrammarLevel = {}));
export var SqlOuterJoinsSupportLevel;
(function (SqlOuterJoinsSupportLevel) {
    SqlOuterJoinsSupportLevel[SqlOuterJoinsSupportLevel["SQL_JOINS_UNSUPPORTED"] = 0] = "SQL_JOINS_UNSUPPORTED";
    SqlOuterJoinsSupportLevel[SqlOuterJoinsSupportLevel["SQL_LIMITED_OUTER_JOINS"] = 1] = "SQL_LIMITED_OUTER_JOINS";
    SqlOuterJoinsSupportLevel[SqlOuterJoinsSupportLevel["SQL_FULL_OUTER_JOINS"] = 2] = "SQL_FULL_OUTER_JOINS";
    SqlOuterJoinsSupportLevel[SqlOuterJoinsSupportLevel["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlOuterJoinsSupportLevel || (SqlOuterJoinsSupportLevel = {}));
export var SqlSupportedGroupBy;
(function (SqlSupportedGroupBy) {
    SqlSupportedGroupBy[SqlSupportedGroupBy["SQL_GROUP_BY_UNRELATED"] = 0] = "SQL_GROUP_BY_UNRELATED";
    SqlSupportedGroupBy[SqlSupportedGroupBy["SQL_GROUP_BY_BEYOND_SELECT"] = 1] = "SQL_GROUP_BY_BEYOND_SELECT";
    SqlSupportedGroupBy[SqlSupportedGroupBy["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlSupportedGroupBy || (SqlSupportedGroupBy = {}));
export var SqlSupportedElementActions;
(function (SqlSupportedElementActions) {
    SqlSupportedElementActions[SqlSupportedElementActions["SQL_ELEMENT_IN_PROCEDURE_CALLS"] = 0] = "SQL_ELEMENT_IN_PROCEDURE_CALLS";
    SqlSupportedElementActions[SqlSupportedElementActions["SQL_ELEMENT_IN_INDEX_DEFINITIONS"] = 1] = "SQL_ELEMENT_IN_INDEX_DEFINITIONS";
    SqlSupportedElementActions[SqlSupportedElementActions["SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS"] = 2] = "SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS";
    SqlSupportedElementActions[SqlSupportedElementActions["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlSupportedElementActions || (SqlSupportedElementActions = {}));
export var SqlSupportedPositionedCommands;
(function (SqlSupportedPositionedCommands) {
    SqlSupportedPositionedCommands[SqlSupportedPositionedCommands["SQL_POSITIONED_DELETE"] = 0] = "SQL_POSITIONED_DELETE";
    SqlSupportedPositionedCommands[SqlSupportedPositionedCommands["SQL_POSITIONED_UPDATE"] = 1] = "SQL_POSITIONED_UPDATE";
    SqlSupportedPositionedCommands[SqlSupportedPositionedCommands["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlSupportedPositionedCommands || (SqlSupportedPositionedCommands = {}));
export var SqlSupportedSubqueries;
(function (SqlSupportedSubqueries) {
    SqlSupportedSubqueries[SqlSupportedSubqueries["SQL_SUBQUERIES_IN_COMPARISONS"] = 0] = "SQL_SUBQUERIES_IN_COMPARISONS";
    SqlSupportedSubqueries[SqlSupportedSubqueries["SQL_SUBQUERIES_IN_EXISTS"] = 1] = "SQL_SUBQUERIES_IN_EXISTS";
    SqlSupportedSubqueries[SqlSupportedSubqueries["SQL_SUBQUERIES_IN_INS"] = 2] = "SQL_SUBQUERIES_IN_INS";
    SqlSupportedSubqueries[SqlSupportedSubqueries["SQL_SUBQUERIES_IN_QUANTIFIEDS"] = 3] = "SQL_SUBQUERIES_IN_QUANTIFIEDS";
    SqlSupportedSubqueries[SqlSupportedSubqueries["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlSupportedSubqueries || (SqlSupportedSubqueries = {}));
export var SqlSupportedUnions;
(function (SqlSupportedUnions) {
    SqlSupportedUnions[SqlSupportedUnions["SQL_UNION"] = 0] = "SQL_UNION";
    SqlSupportedUnions[SqlSupportedUnions["SQL_UNION_ALL"] = 1] = "SQL_UNION_ALL";
    SqlSupportedUnions[SqlSupportedUnions["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlSupportedUnions || (SqlSupportedUnions = {}));
export var SqlTransactionIsolationLevel;
(function (SqlTransactionIsolationLevel) {
    SqlTransactionIsolationLevel[SqlTransactionIsolationLevel["SQL_TRANSACTION_NONE"] = 0] = "SQL_TRANSACTION_NONE";
    SqlTransactionIsolationLevel[SqlTransactionIsolationLevel["SQL_TRANSACTION_READ_UNCOMMITTED"] = 1] = "SQL_TRANSACTION_READ_UNCOMMITTED";
    SqlTransactionIsolationLevel[SqlTransactionIsolationLevel["SQL_TRANSACTION_READ_COMMITTED"] = 2] = "SQL_TRANSACTION_READ_COMMITTED";
    SqlTransactionIsolationLevel[SqlTransactionIsolationLevel["SQL_TRANSACTION_REPEATABLE_READ"] = 3] = "SQL_TRANSACTION_REPEATABLE_READ";
    SqlTransactionIsolationLevel[SqlTransactionIsolationLevel["SQL_TRANSACTION_SERIALIZABLE"] = 4] = "SQL_TRANSACTION_SERIALIZABLE";
    SqlTransactionIsolationLevel[SqlTransactionIsolationLevel["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlTransactionIsolationLevel || (SqlTransactionIsolationLevel = {}));
export var SqlSupportedTransactions;
(function (SqlSupportedTransactions) {
    SqlSupportedTransactions[SqlSupportedTransactions["SQL_TRANSACTION_UNSPECIFIED"] = 0] = "SQL_TRANSACTION_UNSPECIFIED";
    SqlSupportedTransactions[SqlSupportedTransactions["SQL_DATA_DEFINITION_TRANSACTIONS"] = 1] = "SQL_DATA_DEFINITION_TRANSACTIONS";
    SqlSupportedTransactions[SqlSupportedTransactions["SQL_DATA_MANIPULATION_TRANSACTIONS"] = 2] = "SQL_DATA_MANIPULATION_TRANSACTIONS";
    SqlSupportedTransactions[SqlSupportedTransactions["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlSupportedTransactions || (SqlSupportedTransactions = {}));
export var SqlSupportedResultSetType;
(function (SqlSupportedResultSetType) {
    SqlSupportedResultSetType[SqlSupportedResultSetType["SQL_RESULT_SET_TYPE_UNSPECIFIED"] = 0] = "SQL_RESULT_SET_TYPE_UNSPECIFIED";
    SqlSupportedResultSetType[SqlSupportedResultSetType["SQL_RESULT_SET_TYPE_FORWARD_ONLY"] = 1] = "SQL_RESULT_SET_TYPE_FORWARD_ONLY";
    SqlSupportedResultSetType[SqlSupportedResultSetType["SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE"] = 2] = "SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE";
    SqlSupportedResultSetType[SqlSupportedResultSetType["SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE"] = 3] = "SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE";
    SqlSupportedResultSetType[SqlSupportedResultSetType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlSupportedResultSetType || (SqlSupportedResultSetType = {}));
export var SqlSupportedResultSetConcurrency;
(function (SqlSupportedResultSetConcurrency) {
    SqlSupportedResultSetConcurrency[SqlSupportedResultSetConcurrency["SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED"] = 0] = "SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED";
    SqlSupportedResultSetConcurrency[SqlSupportedResultSetConcurrency["SQL_RESULT_SET_CONCURRENCY_READ_ONLY"] = 1] = "SQL_RESULT_SET_CONCURRENCY_READ_ONLY";
    SqlSupportedResultSetConcurrency[SqlSupportedResultSetConcurrency["SQL_RESULT_SET_CONCURRENCY_UPDATABLE"] = 2] = "SQL_RESULT_SET_CONCURRENCY_UPDATABLE";
    SqlSupportedResultSetConcurrency[SqlSupportedResultSetConcurrency["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlSupportedResultSetConcurrency || (SqlSupportedResultSetConcurrency = {}));
export var SqlSupportsConvert;
(function (SqlSupportsConvert) {
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_BIGINT"] = 0] = "SQL_CONVERT_BIGINT";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_BINARY"] = 1] = "SQL_CONVERT_BINARY";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_BIT"] = 2] = "SQL_CONVERT_BIT";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_CHAR"] = 3] = "SQL_CONVERT_CHAR";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_DATE"] = 4] = "SQL_CONVERT_DATE";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_DECIMAL"] = 5] = "SQL_CONVERT_DECIMAL";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_FLOAT"] = 6] = "SQL_CONVERT_FLOAT";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_INTEGER"] = 7] = "SQL_CONVERT_INTEGER";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_INTERVAL_DAY_TIME"] = 8] = "SQL_CONVERT_INTERVAL_DAY_TIME";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_INTERVAL_YEAR_MONTH"] = 9] = "SQL_CONVERT_INTERVAL_YEAR_MONTH";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_LONGVARBINARY"] = 10] = "SQL_CONVERT_LONGVARBINARY";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_LONGVARCHAR"] = 11] = "SQL_CONVERT_LONGVARCHAR";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_NUMERIC"] = 12] = "SQL_CONVERT_NUMERIC";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_REAL"] = 13] = "SQL_CONVERT_REAL";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_SMALLINT"] = 14] = "SQL_CONVERT_SMALLINT";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_TIME"] = 15] = "SQL_CONVERT_TIME";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_TIMESTAMP"] = 16] = "SQL_CONVERT_TIMESTAMP";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_TINYINT"] = 17] = "SQL_CONVERT_TINYINT";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_VARBINARY"] = 18] = "SQL_CONVERT_VARBINARY";
    SqlSupportsConvert[SqlSupportsConvert["SQL_CONVERT_VARCHAR"] = 19] = "SQL_CONVERT_VARCHAR";
    SqlSupportsConvert[SqlSupportsConvert["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SqlSupportsConvert || (SqlSupportsConvert = {}));
/**
 * The JDBC/ODBC-defined type of any object.
 * All the values here are the same as in the JDBC and ODBC specs.
 */
export var XdbcDataType;
(function (XdbcDataType) {
    XdbcDataType[XdbcDataType["XDBC_UNKNOWN_TYPE"] = 0] = "XDBC_UNKNOWN_TYPE";
    XdbcDataType[XdbcDataType["XDBC_CHAR"] = 1] = "XDBC_CHAR";
    XdbcDataType[XdbcDataType["XDBC_NUMERIC"] = 2] = "XDBC_NUMERIC";
    XdbcDataType[XdbcDataType["XDBC_DECIMAL"] = 3] = "XDBC_DECIMAL";
    XdbcDataType[XdbcDataType["XDBC_INTEGER"] = 4] = "XDBC_INTEGER";
    XdbcDataType[XdbcDataType["XDBC_SMALLINT"] = 5] = "XDBC_SMALLINT";
    XdbcDataType[XdbcDataType["XDBC_FLOAT"] = 6] = "XDBC_FLOAT";
    XdbcDataType[XdbcDataType["XDBC_REAL"] = 7] = "XDBC_REAL";
    XdbcDataType[XdbcDataType["XDBC_DOUBLE"] = 8] = "XDBC_DOUBLE";
    XdbcDataType[XdbcDataType["XDBC_DATETIME"] = 9] = "XDBC_DATETIME";
    XdbcDataType[XdbcDataType["XDBC_INTERVAL"] = 10] = "XDBC_INTERVAL";
    XdbcDataType[XdbcDataType["XDBC_VARCHAR"] = 12] = "XDBC_VARCHAR";
    XdbcDataType[XdbcDataType["XDBC_DATE"] = 91] = "XDBC_DATE";
    XdbcDataType[XdbcDataType["XDBC_TIME"] = 92] = "XDBC_TIME";
    XdbcDataType[XdbcDataType["XDBC_TIMESTAMP"] = 93] = "XDBC_TIMESTAMP";
    XdbcDataType[XdbcDataType["XDBC_LONGVARCHAR"] = -1] = "XDBC_LONGVARCHAR";
    XdbcDataType[XdbcDataType["XDBC_BINARY"] = -2] = "XDBC_BINARY";
    XdbcDataType[XdbcDataType["XDBC_VARBINARY"] = -3] = "XDBC_VARBINARY";
    XdbcDataType[XdbcDataType["XDBC_LONGVARBINARY"] = -4] = "XDBC_LONGVARBINARY";
    XdbcDataType[XdbcDataType["XDBC_BIGINT"] = -5] = "XDBC_BIGINT";
    XdbcDataType[XdbcDataType["XDBC_TINYINT"] = -6] = "XDBC_TINYINT";
    XdbcDataType[XdbcDataType["XDBC_BIT"] = -7] = "XDBC_BIT";
    XdbcDataType[XdbcDataType["XDBC_WCHAR"] = -8] = "XDBC_WCHAR";
    XdbcDataType[XdbcDataType["XDBC_WVARCHAR"] = -9] = "XDBC_WVARCHAR";
})(XdbcDataType || (XdbcDataType = {}));
/** Detailed subtype information for XDBC_TYPE_DATETIME and XDBC_TYPE_INTERVAL. */
export var XdbcDatetimeSubcode;
(function (XdbcDatetimeSubcode) {
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_UNKNOWN"] = 0] = "XDBC_SUBCODE_UNKNOWN";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_YEAR"] = 1] = "XDBC_SUBCODE_YEAR";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_DATE"] = 1] = "XDBC_SUBCODE_DATE";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_TIME"] = 2] = "XDBC_SUBCODE_TIME";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_MONTH"] = 2] = "XDBC_SUBCODE_MONTH";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_TIMESTAMP"] = 3] = "XDBC_SUBCODE_TIMESTAMP";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_DAY"] = 3] = "XDBC_SUBCODE_DAY";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_TIME_WITH_TIMEZONE"] = 4] = "XDBC_SUBCODE_TIME_WITH_TIMEZONE";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_HOUR"] = 4] = "XDBC_SUBCODE_HOUR";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_TIMESTAMP_WITH_TIMEZONE"] = 5] = "XDBC_SUBCODE_TIMESTAMP_WITH_TIMEZONE";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_MINUTE"] = 5] = "XDBC_SUBCODE_MINUTE";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_SECOND"] = 6] = "XDBC_SUBCODE_SECOND";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_YEAR_TO_MONTH"] = 7] = "XDBC_SUBCODE_YEAR_TO_MONTH";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_DAY_TO_HOUR"] = 8] = "XDBC_SUBCODE_DAY_TO_HOUR";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_DAY_TO_MINUTE"] = 9] = "XDBC_SUBCODE_DAY_TO_MINUTE";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_DAY_TO_SECOND"] = 10] = "XDBC_SUBCODE_DAY_TO_SECOND";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_HOUR_TO_MINUTE"] = 11] = "XDBC_SUBCODE_HOUR_TO_MINUTE";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_HOUR_TO_SECOND"] = 12] = "XDBC_SUBCODE_HOUR_TO_SECOND";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_MINUTE_TO_SECOND"] = 13] = "XDBC_SUBCODE_MINUTE_TO_SECOND";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_YEAR"] = 101] = "XDBC_SUBCODE_INTERVAL_YEAR";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_MONTH"] = 102] = "XDBC_SUBCODE_INTERVAL_MONTH";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_DAY"] = 103] = "XDBC_SUBCODE_INTERVAL_DAY";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_HOUR"] = 104] = "XDBC_SUBCODE_INTERVAL_HOUR";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_MINUTE"] = 105] = "XDBC_SUBCODE_INTERVAL_MINUTE";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_SECOND"] = 106] = "XDBC_SUBCODE_INTERVAL_SECOND";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_YEAR_TO_MONTH"] = 107] = "XDBC_SUBCODE_INTERVAL_YEAR_TO_MONTH";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_DAY_TO_HOUR"] = 108] = "XDBC_SUBCODE_INTERVAL_DAY_TO_HOUR";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_DAY_TO_MINUTE"] = 109] = "XDBC_SUBCODE_INTERVAL_DAY_TO_MINUTE";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_DAY_TO_SECOND"] = 110] = "XDBC_SUBCODE_INTERVAL_DAY_TO_SECOND";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_HOUR_TO_MINUTE"] = 111] = "XDBC_SUBCODE_INTERVAL_HOUR_TO_MINUTE";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_HOUR_TO_SECOND"] = 112] = "XDBC_SUBCODE_INTERVAL_HOUR_TO_SECOND";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["XDBC_SUBCODE_INTERVAL_MINUTE_TO_SECOND"] = 113] = "XDBC_SUBCODE_INTERVAL_MINUTE_TO_SECOND";
    XdbcDatetimeSubcode[XdbcDatetimeSubcode["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(XdbcDatetimeSubcode || (XdbcDatetimeSubcode = {}));
export var Nullable;
(function (Nullable) {
    /** NULLABILITY_NO_NULLS - Indicates that the fields does not allow the use of null values. */
    Nullable[Nullable["NULLABILITY_NO_NULLS"] = 0] = "NULLABILITY_NO_NULLS";
    /** NULLABILITY_NULLABLE - Indicates that the fields allow the use of null values. */
    Nullable[Nullable["NULLABILITY_NULLABLE"] = 1] = "NULLABILITY_NULLABLE";
    /** NULLABILITY_UNKNOWN - Indicates that nullability of the fields cannot be determined. */
    Nullable[Nullable["NULLABILITY_UNKNOWN"] = 2] = "NULLABILITY_UNKNOWN";
    Nullable[Nullable["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Nullable || (Nullable = {}));
export var Searchable;
(function (Searchable) {
    /** SEARCHABLE_NONE - Indicates that column cannot be used in a WHERE clause. */
    Searchable[Searchable["SEARCHABLE_NONE"] = 0] = "SEARCHABLE_NONE";
    /**
     * SEARCHABLE_CHAR - Indicates that the column can be used in a WHERE clause if it is using a
     * LIKE operator.
     */
    Searchable[Searchable["SEARCHABLE_CHAR"] = 1] = "SEARCHABLE_CHAR";
    /**
     * SEARCHABLE_BASIC - Indicates that the column can be used In a WHERE clause with any
     * operator other than LIKE.
     *
     * - Allowed operators: comparison, quantified comparison, BETWEEN,
     *                      DISTINCT, IN, MATCH, and UNIQUE.
     */
    Searchable[Searchable["SEARCHABLE_BASIC"] = 2] = "SEARCHABLE_BASIC";
    /** SEARCHABLE_FULL - Indicates that the column can be used in a WHERE clause using any operator. */
    Searchable[Searchable["SEARCHABLE_FULL"] = 3] = "SEARCHABLE_FULL";
    Searchable[Searchable["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Searchable || (Searchable = {}));
export var UpdateDeleteRules;
(function (UpdateDeleteRules) {
    UpdateDeleteRules[UpdateDeleteRules["CASCADE"] = 0] = "CASCADE";
    UpdateDeleteRules[UpdateDeleteRules["RESTRICT"] = 1] = "RESTRICT";
    UpdateDeleteRules[UpdateDeleteRules["SET_NULL"] = 2] = "SET_NULL";
    UpdateDeleteRules[UpdateDeleteRules["NO_ACTION"] = 3] = "NO_ACTION";
    UpdateDeleteRules[UpdateDeleteRules["SET_DEFAULT"] = 4] = "SET_DEFAULT";
    UpdateDeleteRules[UpdateDeleteRules["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(UpdateDeleteRules || (UpdateDeleteRules = {}));
export var ActionEndTransactionRequest_EndTransaction;
(function (ActionEndTransactionRequest_EndTransaction) {
    ActionEndTransactionRequest_EndTransaction[ActionEndTransactionRequest_EndTransaction["END_TRANSACTION_UNSPECIFIED"] = 0] = "END_TRANSACTION_UNSPECIFIED";
    /** END_TRANSACTION_COMMIT - Commit the transaction. */
    ActionEndTransactionRequest_EndTransaction[ActionEndTransactionRequest_EndTransaction["END_TRANSACTION_COMMIT"] = 1] = "END_TRANSACTION_COMMIT";
    /** END_TRANSACTION_ROLLBACK - Roll back the transaction. */
    ActionEndTransactionRequest_EndTransaction[ActionEndTransactionRequest_EndTransaction["END_TRANSACTION_ROLLBACK"] = 2] = "END_TRANSACTION_ROLLBACK";
    ActionEndTransactionRequest_EndTransaction[ActionEndTransactionRequest_EndTransaction["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ActionEndTransactionRequest_EndTransaction || (ActionEndTransactionRequest_EndTransaction = {}));
export var ActionEndSavepointRequest_EndSavepoint;
(function (ActionEndSavepointRequest_EndSavepoint) {
    ActionEndSavepointRequest_EndSavepoint[ActionEndSavepointRequest_EndSavepoint["END_SAVEPOINT_UNSPECIFIED"] = 0] = "END_SAVEPOINT_UNSPECIFIED";
    /** END_SAVEPOINT_RELEASE - Release the savepoint. */
    ActionEndSavepointRequest_EndSavepoint[ActionEndSavepointRequest_EndSavepoint["END_SAVEPOINT_RELEASE"] = 1] = "END_SAVEPOINT_RELEASE";
    /** END_SAVEPOINT_ROLLBACK - Roll back to a savepoint. */
    ActionEndSavepointRequest_EndSavepoint[ActionEndSavepointRequest_EndSavepoint["END_SAVEPOINT_ROLLBACK"] = 2] = "END_SAVEPOINT_ROLLBACK";
    ActionEndSavepointRequest_EndSavepoint[ActionEndSavepointRequest_EndSavepoint["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ActionEndSavepointRequest_EndSavepoint || (ActionEndSavepointRequest_EndSavepoint = {}));
/** The action to take if the target table does not exist */
export var CommandStatementIngest_TableDefinitionOptions_TableNotExistOption;
(function (CommandStatementIngest_TableDefinitionOptions_TableNotExistOption) {
    /** TABLE_NOT_EXIST_OPTION_UNSPECIFIED - Do not use. Servers should error if this is specified by a client. */
    CommandStatementIngest_TableDefinitionOptions_TableNotExistOption[CommandStatementIngest_TableDefinitionOptions_TableNotExistOption["TABLE_NOT_EXIST_OPTION_UNSPECIFIED"] = 0] = "TABLE_NOT_EXIST_OPTION_UNSPECIFIED";
    /** TABLE_NOT_EXIST_OPTION_CREATE - Create the table if it does not exist */
    CommandStatementIngest_TableDefinitionOptions_TableNotExistOption[CommandStatementIngest_TableDefinitionOptions_TableNotExistOption["TABLE_NOT_EXIST_OPTION_CREATE"] = 1] = "TABLE_NOT_EXIST_OPTION_CREATE";
    /** TABLE_NOT_EXIST_OPTION_FAIL - Fail if the table does not exist */
    CommandStatementIngest_TableDefinitionOptions_TableNotExistOption[CommandStatementIngest_TableDefinitionOptions_TableNotExistOption["TABLE_NOT_EXIST_OPTION_FAIL"] = 2] = "TABLE_NOT_EXIST_OPTION_FAIL";
    CommandStatementIngest_TableDefinitionOptions_TableNotExistOption[CommandStatementIngest_TableDefinitionOptions_TableNotExistOption["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CommandStatementIngest_TableDefinitionOptions_TableNotExistOption || (CommandStatementIngest_TableDefinitionOptions_TableNotExistOption = {}));
/** The action to take if the target table already exists */
export var CommandStatementIngest_TableDefinitionOptions_TableExistsOption;
(function (CommandStatementIngest_TableDefinitionOptions_TableExistsOption) {
    /** TABLE_EXISTS_OPTION_UNSPECIFIED - Do not use. Servers should error if this is specified by a client. */
    CommandStatementIngest_TableDefinitionOptions_TableExistsOption[CommandStatementIngest_TableDefinitionOptions_TableExistsOption["TABLE_EXISTS_OPTION_UNSPECIFIED"] = 0] = "TABLE_EXISTS_OPTION_UNSPECIFIED";
    /** TABLE_EXISTS_OPTION_FAIL - Fail if the table already exists */
    CommandStatementIngest_TableDefinitionOptions_TableExistsOption[CommandStatementIngest_TableDefinitionOptions_TableExistsOption["TABLE_EXISTS_OPTION_FAIL"] = 1] = "TABLE_EXISTS_OPTION_FAIL";
    /** TABLE_EXISTS_OPTION_APPEND - Append to the table if it already exists */
    CommandStatementIngest_TableDefinitionOptions_TableExistsOption[CommandStatementIngest_TableDefinitionOptions_TableExistsOption["TABLE_EXISTS_OPTION_APPEND"] = 2] = "TABLE_EXISTS_OPTION_APPEND";
    /** TABLE_EXISTS_OPTION_REPLACE - Drop and recreate the table if it already exists */
    CommandStatementIngest_TableDefinitionOptions_TableExistsOption[CommandStatementIngest_TableDefinitionOptions_TableExistsOption["TABLE_EXISTS_OPTION_REPLACE"] = 3] = "TABLE_EXISTS_OPTION_REPLACE";
    CommandStatementIngest_TableDefinitionOptions_TableExistsOption[CommandStatementIngest_TableDefinitionOptions_TableExistsOption["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CommandStatementIngest_TableDefinitionOptions_TableExistsOption || (CommandStatementIngest_TableDefinitionOptions_TableExistsOption = {}));
export var ActionCancelQueryResult_CancelResult;
(function (ActionCancelQueryResult_CancelResult) {
    /**
     * CANCEL_RESULT_UNSPECIFIED - The cancellation status is unknown. Servers should avoid using
     * this value (send a NOT_FOUND error if the requested query is
     * not known). Clients can retry the request.
     */
    ActionCancelQueryResult_CancelResult[ActionCancelQueryResult_CancelResult["CANCEL_RESULT_UNSPECIFIED"] = 0] = "CANCEL_RESULT_UNSPECIFIED";
    /**
     * CANCEL_RESULT_CANCELLED - The cancellation request is complete. Subsequent requests with
     * the same payload may return CANCELLED or a NOT_FOUND error.
     */
    ActionCancelQueryResult_CancelResult[ActionCancelQueryResult_CancelResult["CANCEL_RESULT_CANCELLED"] = 1] = "CANCEL_RESULT_CANCELLED";
    /**
     * CANCEL_RESULT_CANCELLING - The cancellation request is in progress. The client may retry
     * the cancellation request.
     */
    ActionCancelQueryResult_CancelResult[ActionCancelQueryResult_CancelResult["CANCEL_RESULT_CANCELLING"] = 2] = "CANCEL_RESULT_CANCELLING";
    /**
     * CANCEL_RESULT_NOT_CANCELLABLE - The query is not cancellable. The client should not retry the
     * cancellation request.
     */
    ActionCancelQueryResult_CancelResult[ActionCancelQueryResult_CancelResult["CANCEL_RESULT_NOT_CANCELLABLE"] = 3] = "CANCEL_RESULT_NOT_CANCELLABLE";
    ActionCancelQueryResult_CancelResult[ActionCancelQueryResult_CancelResult["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ActionCancelQueryResult_CancelResult || (ActionCancelQueryResult_CancelResult = {}));
function createBaseCommandGetSqlInfo() {
    return { info: [] };
}
export const CommandGetSqlInfo = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.info) {
            writer.uint32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandGetSqlInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.info.push(reader.uint32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.info.push(reader.uint32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandGetSqlInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandGetSqlInfo();
        message.info = object.info?.map((e) => e) || [];
        return message;
    },
};
function createBaseCommandGetXdbcTypeInfo() {
    return { dataType: undefined };
}
export const CommandGetXdbcTypeInfo = {
    encode(message, writer = new BinaryWriter()) {
        if (message.dataType !== undefined) {
            writer.uint32(8).int32(message.dataType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandGetXdbcTypeInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.dataType = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandGetXdbcTypeInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandGetXdbcTypeInfo();
        message.dataType = object.dataType ?? undefined;
        return message;
    },
};
function createBaseCommandGetCatalogs() {
    return {};
}
export const CommandGetCatalogs = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandGetCatalogs();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandGetCatalogs.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseCommandGetCatalogs();
        return message;
    },
};
function createBaseCommandGetDbSchemas() {
    return { catalog: undefined, dbSchemaFilterPattern: undefined };
}
export const CommandGetDbSchemas = {
    encode(message, writer = new BinaryWriter()) {
        if (message.catalog !== undefined) {
            writer.uint32(10).string(message.catalog);
        }
        if (message.dbSchemaFilterPattern !== undefined) {
            writer.uint32(18).string(message.dbSchemaFilterPattern);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandGetDbSchemas();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.catalog = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.dbSchemaFilterPattern = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandGetDbSchemas.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandGetDbSchemas();
        message.catalog = object.catalog ?? undefined;
        message.dbSchemaFilterPattern = object.dbSchemaFilterPattern ?? undefined;
        return message;
    },
};
function createBaseCommandGetTables() {
    return {
        catalog: undefined,
        dbSchemaFilterPattern: undefined,
        tableNameFilterPattern: undefined,
        tableTypes: [],
        includeSchema: false,
    };
}
export const CommandGetTables = {
    encode(message, writer = new BinaryWriter()) {
        if (message.catalog !== undefined) {
            writer.uint32(10).string(message.catalog);
        }
        if (message.dbSchemaFilterPattern !== undefined) {
            writer.uint32(18).string(message.dbSchemaFilterPattern);
        }
        if (message.tableNameFilterPattern !== undefined) {
            writer.uint32(26).string(message.tableNameFilterPattern);
        }
        for (const v of message.tableTypes) {
            writer.uint32(34).string(v);
        }
        if (message.includeSchema !== false) {
            writer.uint32(40).bool(message.includeSchema);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandGetTables();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.catalog = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.dbSchemaFilterPattern = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.tableNameFilterPattern = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.tableTypes.push(reader.string());
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.includeSchema = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandGetTables.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandGetTables();
        message.catalog = object.catalog ?? undefined;
        message.dbSchemaFilterPattern = object.dbSchemaFilterPattern ?? undefined;
        message.tableNameFilterPattern = object.tableNameFilterPattern ?? undefined;
        message.tableTypes = object.tableTypes?.map((e) => e) || [];
        message.includeSchema = object.includeSchema ?? false;
        return message;
    },
};
function createBaseCommandGetTableTypes() {
    return {};
}
export const CommandGetTableTypes = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandGetTableTypes();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandGetTableTypes.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseCommandGetTableTypes();
        return message;
    },
};
function createBaseCommandGetPrimaryKeys() {
    return { catalog: undefined, dbSchema: undefined, table: "" };
}
export const CommandGetPrimaryKeys = {
    encode(message, writer = new BinaryWriter()) {
        if (message.catalog !== undefined) {
            writer.uint32(10).string(message.catalog);
        }
        if (message.dbSchema !== undefined) {
            writer.uint32(18).string(message.dbSchema);
        }
        if (message.table !== "") {
            writer.uint32(26).string(message.table);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandGetPrimaryKeys();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.catalog = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.dbSchema = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.table = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandGetPrimaryKeys.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandGetPrimaryKeys();
        message.catalog = object.catalog ?? undefined;
        message.dbSchema = object.dbSchema ?? undefined;
        message.table = object.table ?? "";
        return message;
    },
};
function createBaseCommandGetExportedKeys() {
    return { catalog: undefined, dbSchema: undefined, table: "" };
}
export const CommandGetExportedKeys = {
    encode(message, writer = new BinaryWriter()) {
        if (message.catalog !== undefined) {
            writer.uint32(10).string(message.catalog);
        }
        if (message.dbSchema !== undefined) {
            writer.uint32(18).string(message.dbSchema);
        }
        if (message.table !== "") {
            writer.uint32(26).string(message.table);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandGetExportedKeys();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.catalog = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.dbSchema = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.table = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandGetExportedKeys.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandGetExportedKeys();
        message.catalog = object.catalog ?? undefined;
        message.dbSchema = object.dbSchema ?? undefined;
        message.table = object.table ?? "";
        return message;
    },
};
function createBaseCommandGetImportedKeys() {
    return { catalog: undefined, dbSchema: undefined, table: "" };
}
export const CommandGetImportedKeys = {
    encode(message, writer = new BinaryWriter()) {
        if (message.catalog !== undefined) {
            writer.uint32(10).string(message.catalog);
        }
        if (message.dbSchema !== undefined) {
            writer.uint32(18).string(message.dbSchema);
        }
        if (message.table !== "") {
            writer.uint32(26).string(message.table);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandGetImportedKeys();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.catalog = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.dbSchema = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.table = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandGetImportedKeys.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandGetImportedKeys();
        message.catalog = object.catalog ?? undefined;
        message.dbSchema = object.dbSchema ?? undefined;
        message.table = object.table ?? "";
        return message;
    },
};
function createBaseCommandGetCrossReference() {
    return {
        pkCatalog: undefined,
        pkDbSchema: undefined,
        pkTable: "",
        fkCatalog: undefined,
        fkDbSchema: undefined,
        fkTable: "",
    };
}
export const CommandGetCrossReference = {
    encode(message, writer = new BinaryWriter()) {
        if (message.pkCatalog !== undefined) {
            writer.uint32(10).string(message.pkCatalog);
        }
        if (message.pkDbSchema !== undefined) {
            writer.uint32(18).string(message.pkDbSchema);
        }
        if (message.pkTable !== "") {
            writer.uint32(26).string(message.pkTable);
        }
        if (message.fkCatalog !== undefined) {
            writer.uint32(34).string(message.fkCatalog);
        }
        if (message.fkDbSchema !== undefined) {
            writer.uint32(42).string(message.fkDbSchema);
        }
        if (message.fkTable !== "") {
            writer.uint32(50).string(message.fkTable);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandGetCrossReference();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.pkCatalog = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.pkDbSchema = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.pkTable = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.fkCatalog = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.fkDbSchema = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.fkTable = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandGetCrossReference.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandGetCrossReference();
        message.pkCatalog = object.pkCatalog ?? undefined;
        message.pkDbSchema = object.pkDbSchema ?? undefined;
        message.pkTable = object.pkTable ?? "";
        message.fkCatalog = object.fkCatalog ?? undefined;
        message.fkDbSchema = object.fkDbSchema ?? undefined;
        message.fkTable = object.fkTable ?? "";
        return message;
    },
};
function createBaseActionCreatePreparedStatementRequest() {
    return { query: "", transactionId: undefined };
}
export const ActionCreatePreparedStatementRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.query !== "") {
            writer.uint32(10).string(message.query);
        }
        if (message.transactionId !== undefined) {
            writer.uint32(18).bytes(message.transactionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionCreatePreparedStatementRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.query = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.transactionId = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionCreatePreparedStatementRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActionCreatePreparedStatementRequest();
        message.query = object.query ?? "";
        message.transactionId = object.transactionId ?? undefined;
        return message;
    },
};
function createBaseSubstraitPlan() {
    return { plan: new Uint8Array(0), version: "" };
}
export const SubstraitPlan = {
    encode(message, writer = new BinaryWriter()) {
        if (message.plan.length !== 0) {
            writer.uint32(10).bytes(message.plan);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubstraitPlan();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.plan = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return SubstraitPlan.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubstraitPlan();
        message.plan = object.plan ?? new Uint8Array(0);
        message.version = object.version ?? "";
        return message;
    },
};
function createBaseActionCreatePreparedSubstraitPlanRequest() {
    return { plan: undefined, transactionId: undefined };
}
export const ActionCreatePreparedSubstraitPlanRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.plan !== undefined) {
            SubstraitPlan.encode(message.plan, writer.uint32(10).fork()).join();
        }
        if (message.transactionId !== undefined) {
            writer.uint32(18).bytes(message.transactionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionCreatePreparedSubstraitPlanRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.plan = SubstraitPlan.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.transactionId = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionCreatePreparedSubstraitPlanRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActionCreatePreparedSubstraitPlanRequest();
        message.plan = (object.plan !== undefined && object.plan !== null)
            ? SubstraitPlan.fromPartial(object.plan)
            : undefined;
        message.transactionId = object.transactionId ?? undefined;
        return message;
    },
};
function createBaseActionCreatePreparedStatementResult() {
    return {
        preparedStatementHandle: new Uint8Array(0),
        datasetSchema: new Uint8Array(0),
        parameterSchema: new Uint8Array(0),
    };
}
export const ActionCreatePreparedStatementResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.preparedStatementHandle.length !== 0) {
            writer.uint32(10).bytes(message.preparedStatementHandle);
        }
        if (message.datasetSchema.length !== 0) {
            writer.uint32(18).bytes(message.datasetSchema);
        }
        if (message.parameterSchema.length !== 0) {
            writer.uint32(26).bytes(message.parameterSchema);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionCreatePreparedStatementResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.preparedStatementHandle = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.datasetSchema = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.parameterSchema = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionCreatePreparedStatementResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActionCreatePreparedStatementResult();
        message.preparedStatementHandle = object.preparedStatementHandle ?? new Uint8Array(0);
        message.datasetSchema = object.datasetSchema ?? new Uint8Array(0);
        message.parameterSchema = object.parameterSchema ?? new Uint8Array(0);
        return message;
    },
};
function createBaseActionClosePreparedStatementRequest() {
    return { preparedStatementHandle: new Uint8Array(0) };
}
export const ActionClosePreparedStatementRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.preparedStatementHandle.length !== 0) {
            writer.uint32(10).bytes(message.preparedStatementHandle);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionClosePreparedStatementRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.preparedStatementHandle = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionClosePreparedStatementRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActionClosePreparedStatementRequest();
        message.preparedStatementHandle = object.preparedStatementHandle ?? new Uint8Array(0);
        return message;
    },
};
function createBaseActionBeginTransactionRequest() {
    return {};
}
export const ActionBeginTransactionRequest = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionBeginTransactionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionBeginTransactionRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseActionBeginTransactionRequest();
        return message;
    },
};
function createBaseActionBeginSavepointRequest() {
    return { transactionId: new Uint8Array(0), name: "" };
}
export const ActionBeginSavepointRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transactionId.length !== 0) {
            writer.uint32(10).bytes(message.transactionId);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionBeginSavepointRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transactionId = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionBeginSavepointRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActionBeginSavepointRequest();
        message.transactionId = object.transactionId ?? new Uint8Array(0);
        message.name = object.name ?? "";
        return message;
    },
};
function createBaseActionBeginTransactionResult() {
    return { transactionId: new Uint8Array(0) };
}
export const ActionBeginTransactionResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transactionId.length !== 0) {
            writer.uint32(10).bytes(message.transactionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionBeginTransactionResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transactionId = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionBeginTransactionResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActionBeginTransactionResult();
        message.transactionId = object.transactionId ?? new Uint8Array(0);
        return message;
    },
};
function createBaseActionBeginSavepointResult() {
    return { savepointId: new Uint8Array(0) };
}
export const ActionBeginSavepointResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.savepointId.length !== 0) {
            writer.uint32(10).bytes(message.savepointId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionBeginSavepointResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.savepointId = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionBeginSavepointResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActionBeginSavepointResult();
        message.savepointId = object.savepointId ?? new Uint8Array(0);
        return message;
    },
};
function createBaseActionEndTransactionRequest() {
    return { transactionId: new Uint8Array(0), action: 0 };
}
export const ActionEndTransactionRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transactionId.length !== 0) {
            writer.uint32(10).bytes(message.transactionId);
        }
        if (message.action !== 0) {
            writer.uint32(16).int32(message.action);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionEndTransactionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transactionId = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.action = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionEndTransactionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActionEndTransactionRequest();
        message.transactionId = object.transactionId ?? new Uint8Array(0);
        message.action = object.action ?? 0;
        return message;
    },
};
function createBaseActionEndSavepointRequest() {
    return { savepointId: new Uint8Array(0), action: 0 };
}
export const ActionEndSavepointRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.savepointId.length !== 0) {
            writer.uint32(10).bytes(message.savepointId);
        }
        if (message.action !== 0) {
            writer.uint32(16).int32(message.action);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionEndSavepointRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.savepointId = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.action = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionEndSavepointRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActionEndSavepointRequest();
        message.savepointId = object.savepointId ?? new Uint8Array(0);
        message.action = object.action ?? 0;
        return message;
    },
};
function createBaseCommandStatementQuery() {
    return { query: "", transactionId: undefined };
}
export const CommandStatementQuery = {
    encode(message, writer = new BinaryWriter()) {
        if (message.query !== "") {
            writer.uint32(10).string(message.query);
        }
        if (message.transactionId !== undefined) {
            writer.uint32(18).bytes(message.transactionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandStatementQuery();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.query = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.transactionId = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandStatementQuery.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandStatementQuery();
        message.query = object.query ?? "";
        message.transactionId = object.transactionId ?? undefined;
        return message;
    },
};
function createBaseCommandStatementSubstraitPlan() {
    return { plan: undefined, transactionId: undefined };
}
export const CommandStatementSubstraitPlan = {
    encode(message, writer = new BinaryWriter()) {
        if (message.plan !== undefined) {
            SubstraitPlan.encode(message.plan, writer.uint32(10).fork()).join();
        }
        if (message.transactionId !== undefined) {
            writer.uint32(18).bytes(message.transactionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandStatementSubstraitPlan();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.plan = SubstraitPlan.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.transactionId = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandStatementSubstraitPlan.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandStatementSubstraitPlan();
        message.plan = (object.plan !== undefined && object.plan !== null)
            ? SubstraitPlan.fromPartial(object.plan)
            : undefined;
        message.transactionId = object.transactionId ?? undefined;
        return message;
    },
};
function createBaseTicketStatementQuery() {
    return { statementHandle: new Uint8Array(0) };
}
export const TicketStatementQuery = {
    encode(message, writer = new BinaryWriter()) {
        if (message.statementHandle.length !== 0) {
            writer.uint32(10).bytes(message.statementHandle);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTicketStatementQuery();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.statementHandle = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return TicketStatementQuery.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTicketStatementQuery();
        message.statementHandle = object.statementHandle ?? new Uint8Array(0);
        return message;
    },
};
function createBaseCommandPreparedStatementQuery() {
    return { preparedStatementHandle: new Uint8Array(0) };
}
export const CommandPreparedStatementQuery = {
    encode(message, writer = new BinaryWriter()) {
        if (message.preparedStatementHandle.length !== 0) {
            writer.uint32(10).bytes(message.preparedStatementHandle);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandPreparedStatementQuery();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.preparedStatementHandle = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandPreparedStatementQuery.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandPreparedStatementQuery();
        message.preparedStatementHandle = object.preparedStatementHandle ?? new Uint8Array(0);
        return message;
    },
};
function createBaseCommandStatementUpdate() {
    return { query: "", transactionId: undefined };
}
export const CommandStatementUpdate = {
    encode(message, writer = new BinaryWriter()) {
        if (message.query !== "") {
            writer.uint32(10).string(message.query);
        }
        if (message.transactionId !== undefined) {
            writer.uint32(18).bytes(message.transactionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandStatementUpdate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.query = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.transactionId = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandStatementUpdate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandStatementUpdate();
        message.query = object.query ?? "";
        message.transactionId = object.transactionId ?? undefined;
        return message;
    },
};
function createBaseCommandPreparedStatementUpdate() {
    return { preparedStatementHandle: new Uint8Array(0) };
}
export const CommandPreparedStatementUpdate = {
    encode(message, writer = new BinaryWriter()) {
        if (message.preparedStatementHandle.length !== 0) {
            writer.uint32(10).bytes(message.preparedStatementHandle);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandPreparedStatementUpdate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.preparedStatementHandle = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandPreparedStatementUpdate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandPreparedStatementUpdate();
        message.preparedStatementHandle = object.preparedStatementHandle ?? new Uint8Array(0);
        return message;
    },
};
function createBaseCommandStatementIngest() {
    return {
        tableDefinitionOptions: undefined,
        table: "",
        schema: undefined,
        catalog: undefined,
        temporary: false,
        transactionId: undefined,
        options: {},
    };
}
export const CommandStatementIngest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.tableDefinitionOptions !== undefined) {
            CommandStatementIngest_TableDefinitionOptions.encode(message.tableDefinitionOptions, writer.uint32(10).fork())
                .join();
        }
        if (message.table !== "") {
            writer.uint32(18).string(message.table);
        }
        if (message.schema !== undefined) {
            writer.uint32(26).string(message.schema);
        }
        if (message.catalog !== undefined) {
            writer.uint32(34).string(message.catalog);
        }
        if (message.temporary !== false) {
            writer.uint32(40).bool(message.temporary);
        }
        if (message.transactionId !== undefined) {
            writer.uint32(50).bytes(message.transactionId);
        }
        Object.entries(message.options).forEach(([key, value]) => {
            CommandStatementIngest_OptionsEntry.encode({ key: key, value }, writer.uint32(8002).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandStatementIngest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.tableDefinitionOptions = CommandStatementIngest_TableDefinitionOptions.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.table = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.schema = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.catalog = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.temporary = reader.bool();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.transactionId = reader.bytes();
                    continue;
                }
                case 1000: {
                    if (tag !== 8002) {
                        break;
                    }
                    const entry1000 = CommandStatementIngest_OptionsEntry.decode(reader, reader.uint32());
                    if (entry1000.value !== undefined) {
                        message.options[entry1000.key] = entry1000.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandStatementIngest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandStatementIngest();
        message.tableDefinitionOptions =
            (object.tableDefinitionOptions !== undefined && object.tableDefinitionOptions !== null)
                ? CommandStatementIngest_TableDefinitionOptions.fromPartial(object.tableDefinitionOptions)
                : undefined;
        message.table = object.table ?? "";
        message.schema = object.schema ?? undefined;
        message.catalog = object.catalog ?? undefined;
        message.temporary = object.temporary ?? false;
        message.transactionId = object.transactionId ?? undefined;
        message.options = Object.entries(object.options ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseCommandStatementIngest_TableDefinitionOptions() {
    return { ifNotExist: 0, ifExists: 0 };
}
export const CommandStatementIngest_TableDefinitionOptions = {
    encode(message, writer = new BinaryWriter()) {
        if (message.ifNotExist !== 0) {
            writer.uint32(8).int32(message.ifNotExist);
        }
        if (message.ifExists !== 0) {
            writer.uint32(16).int32(message.ifExists);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandStatementIngest_TableDefinitionOptions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.ifNotExist = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.ifExists = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandStatementIngest_TableDefinitionOptions.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandStatementIngest_TableDefinitionOptions();
        message.ifNotExist = object.ifNotExist ?? 0;
        message.ifExists = object.ifExists ?? 0;
        return message;
    },
};
function createBaseCommandStatementIngest_OptionsEntry() {
    return { key: "", value: "" };
}
export const CommandStatementIngest_OptionsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommandStatementIngest_OptionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return CommandStatementIngest_OptionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommandStatementIngest_OptionsEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseDoPutUpdateResult() {
    return { recordCount: 0 };
}
export const DoPutUpdateResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.recordCount !== 0) {
            writer.uint32(8).int64(message.recordCount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDoPutUpdateResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.recordCount = longToNumber(reader.int64());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return DoPutUpdateResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDoPutUpdateResult();
        message.recordCount = object.recordCount ?? 0;
        return message;
    },
};
function createBaseDoPutPreparedStatementResult() {
    return { preparedStatementHandle: undefined };
}
export const DoPutPreparedStatementResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.preparedStatementHandle !== undefined) {
            writer.uint32(10).bytes(message.preparedStatementHandle);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDoPutPreparedStatementResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.preparedStatementHandle = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return DoPutPreparedStatementResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDoPutPreparedStatementResult();
        message.preparedStatementHandle = object.preparedStatementHandle ?? undefined;
        return message;
    },
};
function createBaseActionCancelQueryRequest() {
    return { info: new Uint8Array(0) };
}
export const ActionCancelQueryRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.info.length !== 0) {
            writer.uint32(10).bytes(message.info);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionCancelQueryRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.info = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionCancelQueryRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActionCancelQueryRequest();
        message.info = object.info ?? new Uint8Array(0);
        return message;
    },
};
function createBaseActionCancelQueryResult() {
    return { result: 0 };
}
export const ActionCancelQueryResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.result !== 0) {
            writer.uint32(8).int32(message.result);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActionCancelQueryResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.result = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    create(base) {
        return ActionCancelQueryResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActionCancelQueryResult();
        message.result = object.result ?? 0;
        return message;
    },
};
function longToNumber(int64) {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return num;
}
